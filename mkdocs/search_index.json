{
    "docs": [
        {
            "location": "/", 
            "text": "HOME\n\n\nHere you'll find some general information about the site JSON Schema\n\n\nAbout this site\n\n\nThis site is intended to be a complete and understandable guide to \nJSON Schema\n. You can find an exhaustive specification with intuitive examples. The people behind this project form part of the \nComputer Science Department\n at \nPUC Chile\n, and belong to the \nCenter for Semantic Web Research\n.\n\n\n\n\nWhat is JSON?\n\n\nJSON\n (JavaScript Object Notation) is a file format commonly used for sharing information over the Web. JSON files are lightweight and easy to read both by machines and developers. This has made JSON the most popular file format for client-server communication. The next example JSON file contains information about the famous Chilean football player Gary Medel.\n\n\ngary_medel.json\n\n\n{\n    \"first_name\": \"Alexis\",\n    \"last_name\": \"Sanchez\",\n    \"age\": 27,\n    \"club\": {\n        \"name\": \"Arsenal FC\",\n        \"founded\": 1886\n    } \n}\n\n\n\n\n\nWhat is JSON Schema?\n\n\nA JSON Schema is a file that specifies the structure of JSON documents used by a certain application. For example, when sharing information about football players, one would like to ensure that a JSON document corresponding to a player has a given structure. A JSON Schema is a JSON document in which some words (keywords) have a predefined meaning. The next example schema specifies documents like \ngary_medel.json\n.\n\n\nplayer_schema.json\n\n\n{\n    \"type\": \"object\",\n    \"properties\": {\n        \"first_name\": { \"type\": \"string\" },\n        \"last_name\": { \"type\": \"string\" },\n        \"age\": { \"type\": \"integer\" },\n        \"club\": {\n            \"type\": \"object\",\n            \"properties\": {\n                \"name\": { \"type\": \"string\" },\n                \"founded\": { \"type\": \"integer\" }\n            },\n            \"required\": [\"name\"]\n        }\n    },\n    \"required\": [\"first_name\", \"last_name\", \"age\", \"club\"]\n}\n\n\n\n\nIntuitively, using this schema we are saying that our JSON documents have to have a property \n\"first_name\"\n with a string value, a property \n\"last_name\"\n and so on. Additionally, we also require that some of the information, like \n\"first_name\", \"last_name\", \"age\"\n and  \n\"club\"\n details are present in each document conforming to the schema, while other properties may be ommited.\n\n\nWhy to use JSON Schema\n\n\nThere are several reasons to use a schema when storing data or sharing data over the Web. Some of the benefits:\n\n\n\n\nFiltering content:\n When storing files or receiving files over the web, programmers always want to ensure the data comes in the right format. JSON Schema allows for on-the-fly validation of JSON files.\n\n\nCompression:\n If a schema is known by both the source and the target when sharing information, the network load can be decreased by compressing property names.\n\n\nStandardization:\n Today many APIs receive JSON files as instructions. For example, you can send a JSON file to Twitter's API indicating you want the last five tweets of a user. To use one of these APIs, you need to read the documentation provided by the API developers. Sometimes this documentation is messy and hard to read. If APIs defined a JSON Schema for input files, one could easily understand the allowed JSON files. Moreover, this allows for creating automation tools. For example, given a JSON Schema one could automatically generate a set of example API calls.", 
            "title": "Home"
        }, 
        {
            "location": "/#about-this-site", 
            "text": "This site is intended to be a complete and understandable guide to  JSON Schema . You can find an exhaustive specification with intuitive examples. The people behind this project form part of the  Computer Science Department  at  PUC Chile , and belong to the  Center for Semantic Web Research .", 
            "title": "About this site"
        }, 
        {
            "location": "/#what-is-json", 
            "text": "JSON  (JavaScript Object Notation) is a file format commonly used for sharing information over the Web. JSON files are lightweight and easy to read both by machines and developers. This has made JSON the most popular file format for client-server communication. The next example JSON file contains information about the famous Chilean football player Gary Medel.  gary_medel.json  {\n    \"first_name\": \"Alexis\",\n    \"last_name\": \"Sanchez\",\n    \"age\": 27,\n    \"club\": {\n        \"name\": \"Arsenal FC\",\n        \"founded\": 1886\n    } \n}", 
            "title": "What is JSON?"
        }, 
        {
            "location": "/#what-is-json-schema", 
            "text": "A JSON Schema is a file that specifies the structure of JSON documents used by a certain application. For example, when sharing information about football players, one would like to ensure that a JSON document corresponding to a player has a given structure. A JSON Schema is a JSON document in which some words (keywords) have a predefined meaning. The next example schema specifies documents like  gary_medel.json .  player_schema.json  {\n    \"type\": \"object\",\n    \"properties\": {\n        \"first_name\": { \"type\": \"string\" },\n        \"last_name\": { \"type\": \"string\" },\n        \"age\": { \"type\": \"integer\" },\n        \"club\": {\n            \"type\": \"object\",\n            \"properties\": {\n                \"name\": { \"type\": \"string\" },\n                \"founded\": { \"type\": \"integer\" }\n            },\n            \"required\": [\"name\"]\n        }\n    },\n    \"required\": [\"first_name\", \"last_name\", \"age\", \"club\"]\n}   Intuitively, using this schema we are saying that our JSON documents have to have a property  \"first_name\"  with a string value, a property  \"last_name\"  and so on. Additionally, we also require that some of the information, like  \"first_name\", \"last_name\", \"age\"  and   \"club\"  details are present in each document conforming to the schema, while other properties may be ommited.", 
            "title": "What is JSON Schema?"
        }, 
        {
            "location": "/#why-to-use-json-schema", 
            "text": "There are several reasons to use a schema when storing data or sharing data over the Web. Some of the benefits:   Filtering content:  When storing files or receiving files over the web, programmers always want to ensure the data comes in the right format. JSON Schema allows for on-the-fly validation of JSON files.  Compression:  If a schema is known by both the source and the target when sharing information, the network load can be decreased by compressing property names.  Standardization:  Today many APIs receive JSON files as instructions. For example, you can send a JSON file to Twitter's API indicating you want the last five tweets of a user. To use one of these APIs, you need to read the documentation provided by the API developers. Sometimes this documentation is messy and hard to read. If APIs defined a JSON Schema for input files, one could easily understand the allowed JSON files. Moreover, this allows for creating automation tools. For example, given a JSON Schema one could automatically generate a set of example API calls.", 
            "title": "Why to use JSON Schema"
        }, 
        {
            "location": "/spec/introduction/", 
            "text": "Introduction\n\n\nThe basic concepts needed before diving into the world of JSON Schema\n\n\nHere we present a brief description of some concepts that will make the reading of the specification easier. The \nfirst section\n explains what a JSON document is, which is essential for understanding the definition of JSON Schemas and how they work. The \nsecond section\n contains a simple explanation of what a JSON Schema is together with a small example. Finally, in the \nthird section\n we present some notation that is used throughout the specification to avoid ambiguities.\n\n\nJSON\n\n\nJSON\n (JavaScript Object Notation) is a file format commonly used for sharing information over the Web. JSON files are lightweight and easy to ready both by machines and developers. This has made JSON the most popular file format for client-server communication. A JSON instance is one of the next seven elements:\n\n\n\n\n\n\nstring\n A string is a sequence of valid characters between quotes. For example, \n\"Hello!\"\n is a string, but \n23\n isn't.\n\n\n\n\n\n\nnumber\n A number is created using \nJSON notation\n. For example \n-2\n, \n23\n, \n3.14\n and \n2.54e3\n are all numbers in JSON. \n\n\n\n\n\n\ninteger\n An integers is a JSON number without a fractional part. For example, \n34\n and \n-91\n are integers.\n\n\n\n\n\n\nboolean\n A boolean JSON object is one of two values: \ntrue\n or \nfalse\n.\n\n\n\n\n\n\nnull\n A null object in JSON is the value \nnull\n.\n\n\n\n\n\n\narray\n A JSON array is an ordered sequence of JSON documents separated by commas and enclosed in brackets. For example, \n[\"Hello\", 23, true, null]\n is a JSON array, as well as \n[-2, -1, 3.14, 1.62e10]\n.\n\n\n\n\n\n\nobject\n A JSON object is a set of pairs of the form \nkey:value\n, where \nkey\n is a JSON string and \nvalue\n is a JSON document. These pairs are separated by commas and enclosed in braces. JSON objects are the most common type of JSON documents. For instance, to describe specific information about a product, we might want to remember its \nid\n, \nname\n and the quantity of the product remaining in stock. The following JSON object contains this information:\n\n\n\n\n\n\nmilk.json\n\n\n{\n     \"id\": 1,\n     \"name\": \"Milk\",\n     \"stock\": 25     \n}\n\n\n\nBasic JSON constructs described above can be combined to create more complex documents. To illustrate this consider a situation where we want to store information about multiple products. In order to do so we could use an \narray\n of \nobjects\n of the form above. As an example consider the following JSON document.\n\n\nproducts.json\n\n\n[\n    {\"id\": 1,\n     \"name\": \"Milk\",\n     \"stock\": 25},\n    {\"id\": 2,\n     \"name\": \"Yogurt\",\n     \"stock\": 15,\n     \"link\": \"http://delicious-yogurt.com\"}\n]\n\n\n\nHere our JSON document is an \narray\n that consists of two \nobjects\n, the first one storing information about Milk and the second one about Yogurt.\n\n\nJSON Schema\n\n\nA JSON Schema is a file that specifies the structure of \nJSON documents\n that are used in a certain application. For example, owners of a store might want to share documents with the information about products. Here, a JSON Schema could specify that each such document is a list of products, and that each product contains an \nid\n, a \nname\n, a \nstock\n and optionally a \nlink\n to the manufacturer's website. Since it is very simple to verify if a JSON document \nsatisfies\n  a schema, using a schema would be useful to ensure that all shared documents have this structure. The next JSON Schema specifies the structure of an \narray\n \nproducts.json\n defined above:\n\n\nproduct_list_schema.json\n\n\n{  \n    \"type\": \"array\",\n    \"items\": {\n        \"type\": \"object\",\n        \"properties\": {\n            \"id\": {\"type\": \"integer\"},\n            \"name\": {\"type\": \"string\"},\n            \"stock\": {\"type\": \"integer\"},\n            \"link\": {\"type\": \"string\"},\n        },\n        \"required\": [\"id\", \"name\", \"stock\"],\n        \"additionalProperties\": false\n    }\n}\n\n\n\nFirst, \n\"type\": \"array\"\n indicates that the document must be an array. Then, \n\"items\": {...}\n tells us that each of the array's items must satisfy what's specified in the braces (which is also a schema). Hence, \n\"type\": \"object\"\n indicates that each item of the array must be an object, and \n\"properties\": {...}\n indicates what should be satisfied (also a schema) by the properties of each product. Finally, \n\"required\": [\"id\", \"name\", \"stock\"]\n specifies that each product must have an \nid\n, a \nname\n and a \nstock\n, and \n\"additionalProperties\": false\n says that a product cannot have properties that are not mentioned in \n\"properties\": {...}\n (and hence the only optional property is \nlink\n).\n\n\nNote that the file \nproducts.json\n is \ncorrect\n according to what is specified in \nproduct_list_schema.json\n. \n\n\nNotation\n\n\n\n\nJSON Document\n: A document containing a JSON instance in its content.\n\n\nJSON Schema Document\n: A document containing a JSON Schema instance in addition to a set of JSON Schema instance definitions in its content.\n\n\nJSON Schema\n: A JSON Schema instance. Note that these kind of instances do not include definitions on their structure.\n\n\ndefinitions\n : A set of auxiliary schemas whose purpouse is to be reused and combined later on the schema or in other definitions. You can take a look at the precise formalization \nhere\n.\n\n\nkey-value pair\n: A key-value pair represents an assigment from a particular keyword to a JSON instance.\n\n\nrestriction\n: A single condition that a JSON instance must satisfy. A JSON Schema can be seen as a set of restrictions.\n\n\n\nWe use a simple, visual-based Extended Backus-Naur Form (EBNF) notation to specify how documents are written.  You can look at the \nPrecise Definition\n.\n\n\nWhere to go from here\n\n\nYou can visit our \nUser Guide\n for a quick reference on how to create JSON Schemas. If you want to understand in detail how a keyword is validated, please go to the corresponding section of the specification. The specification is intended to be exhaustive and should contain the information needed to write your own JSON Schema validator (if this is not the case please open an issue).", 
            "title": "Introduction"
        }, 
        {
            "location": "/spec/introduction/#introduction", 
            "text": "The basic concepts needed before diving into the world of JSON Schema  Here we present a brief description of some concepts that will make the reading of the specification easier. The  first section  explains what a JSON document is, which is essential for understanding the definition of JSON Schemas and how they work. The  second section  contains a simple explanation of what a JSON Schema is together with a small example. Finally, in the  third section  we present some notation that is used throughout the specification to avoid ambiguities.", 
            "title": "Introduction"
        }, 
        {
            "location": "/spec/introduction/#json", 
            "text": "JSON  (JavaScript Object Notation) is a file format commonly used for sharing information over the Web. JSON files are lightweight and easy to ready both by machines and developers. This has made JSON the most popular file format for client-server communication. A JSON instance is one of the next seven elements:    string  A string is a sequence of valid characters between quotes. For example,  \"Hello!\"  is a string, but  23  isn't.    number  A number is created using  JSON notation . For example  -2 ,  23 ,  3.14  and  2.54e3  are all numbers in JSON.     integer  An integers is a JSON number without a fractional part. For example,  34  and  -91  are integers.    boolean  A boolean JSON object is one of two values:  true  or  false .    null  A null object in JSON is the value  null .    array  A JSON array is an ordered sequence of JSON documents separated by commas and enclosed in brackets. For example,  [\"Hello\", 23, true, null]  is a JSON array, as well as  [-2, -1, 3.14, 1.62e10] .    object  A JSON object is a set of pairs of the form  key:value , where  key  is a JSON string and  value  is a JSON document. These pairs are separated by commas and enclosed in braces. JSON objects are the most common type of JSON documents. For instance, to describe specific information about a product, we might want to remember its  id ,  name  and the quantity of the product remaining in stock. The following JSON object contains this information:    milk.json  {\n     \"id\": 1,\n     \"name\": \"Milk\",\n     \"stock\": 25     \n}  Basic JSON constructs described above can be combined to create more complex documents. To illustrate this consider a situation where we want to store information about multiple products. In order to do so we could use an  array  of  objects  of the form above. As an example consider the following JSON document.  products.json  [\n    {\"id\": 1,\n     \"name\": \"Milk\",\n     \"stock\": 25},\n    {\"id\": 2,\n     \"name\": \"Yogurt\",\n     \"stock\": 15,\n     \"link\": \"http://delicious-yogurt.com\"}\n]  Here our JSON document is an  array  that consists of two  objects , the first one storing information about Milk and the second one about Yogurt.", 
            "title": "JSON"
        }, 
        {
            "location": "/spec/introduction/#json-schema", 
            "text": "A JSON Schema is a file that specifies the structure of  JSON documents  that are used in a certain application. For example, owners of a store might want to share documents with the information about products. Here, a JSON Schema could specify that each such document is a list of products, and that each product contains an  id , a  name , a  stock  and optionally a  link  to the manufacturer's website. Since it is very simple to verify if a JSON document  satisfies   a schema, using a schema would be useful to ensure that all shared documents have this structure. The next JSON Schema specifies the structure of an  array   products.json  defined above:  product_list_schema.json  {  \n    \"type\": \"array\",\n    \"items\": {\n        \"type\": \"object\",\n        \"properties\": {\n            \"id\": {\"type\": \"integer\"},\n            \"name\": {\"type\": \"string\"},\n            \"stock\": {\"type\": \"integer\"},\n            \"link\": {\"type\": \"string\"},\n        },\n        \"required\": [\"id\", \"name\", \"stock\"],\n        \"additionalProperties\": false\n    }\n}  First,  \"type\": \"array\"  indicates that the document must be an array. Then,  \"items\": {...}  tells us that each of the array's items must satisfy what's specified in the braces (which is also a schema). Hence,  \"type\": \"object\"  indicates that each item of the array must be an object, and  \"properties\": {...}  indicates what should be satisfied (also a schema) by the properties of each product. Finally,  \"required\": [\"id\", \"name\", \"stock\"]  specifies that each product must have an  id , a  name  and a  stock , and  \"additionalProperties\": false  says that a product cannot have properties that are not mentioned in  \"properties\": {...}  (and hence the only optional property is  link ).  Note that the file  products.json  is  correct  according to what is specified in  product_list_schema.json .", 
            "title": "JSON Schema"
        }, 
        {
            "location": "/spec/introduction/#notation", 
            "text": "JSON Document : A document containing a JSON instance in its content.  JSON Schema Document : A document containing a JSON Schema instance in addition to a set of JSON Schema instance definitions in its content.  JSON Schema : A JSON Schema instance. Note that these kind of instances do not include definitions on their structure.  definitions  : A set of auxiliary schemas whose purpouse is to be reused and combined later on the schema or in other definitions. You can take a look at the precise formalization  here .  key-value pair : A key-value pair represents an assigment from a particular keyword to a JSON instance.  restriction : A single condition that a JSON instance must satisfy. A JSON Schema can be seen as a set of restrictions.  We use a simple, visual-based Extended Backus-Naur Form (EBNF) notation to specify how documents are written.  You can look at the  Precise Definition .", 
            "title": "Notation"
        }, 
        {
            "location": "/spec/introduction/#where-to-go-from-here", 
            "text": "You can visit our  User Guide  for a quick reference on how to create JSON Schemas. If you want to understand in detail how a keyword is validated, please go to the corresponding section of the specification. The specification is intended to be exhaustive and should contain the information needed to write your own JSON Schema validator (if this is not the case please open an issue).", 
            "title": "Where to go from here"
        }, 
        {
            "location": "/spec/basic_types/", 
            "text": "Basic Types\n\n\nJSON Documents can be either basic values (strings, numbers, integers, the boolean constants or null), or ordered or unordered list of key:value pairs. We can use JSON Schema to specify that documents can be any of these. For now we concentrate on the specification for values. There are five basic value types supported by JSON Schema: \n\n\n\n\nstring\n \n\n\nnumber\n  \n\n\ninteger\n\n\nboolean\n\n\nnull\n\n\n\n\nString Schemas\n\n\nOne of the most basic forms of values that appear in JSON documents are strings of text. In JSON schema we can specify that a document is a string by using the keyword \nstring\n as the value of the name \ntype\n. That is, the document\n\n\n{\"type\": \"string\"}\n\n\n\nis a JSON Schema that valiadates against any JSON that is a string. Note that a JSON document is a string only if it is a sequence of Unicode characters enclosed in double quotation marks. That is, \n\"I am a string\"\n is a valid JSON document that satisfies the above schema, but so is the sequence \n\"42\"\n, or \n\"true\"\n. On the other hand\n\n42\n is a JSON document that will \nnot\n satisfy the above schema, and neither will the document \ntrue\n.   \n\n\nRestrictions\n\n\nIn order to control the length of our string we can use the keywords \nminLength\n and \nmaxLength\n. To restrict the shape of the string even further we can specify that it conforms to a regular expression using the keyword \npattern\n. \n\n\nRestricting the length of a string\n\n\nWe use the \n\"minLength\"\n and \n\"maxLength\"\n keywords to specify that the length of a string has to fall into a particular interval. For instance, the following schema\n\n\n{\n  \"type\": \"string\", \n  \"minLength\": 3,\n  \"maxLength\": 7\n}\n\n\n\nspecifies that our JSON document is a string whose minimum length is 3 and whose maximum length is 7. The keywords  \n\"minLength\"\n and \n\"maxLength\"\n always have a non-negative integer as their value. The document \n\"This is\"\n will validate against the above schema, as it is of length seven. On the other hand \n\"Is\"\n, or \n\"This is not valid\"\n will not validate against the schema, as the former is too short, while the latter is too long.\n\n\nRegular expressions\n\n\nTo specify that a string conforms to a regular expression we use the keyword \n\"pattern\"\n. For instance, if we want to enforce that the string is a valid email address with the extension \ngmail.com\n that contains only letters of the alphabet, we could use the following JSON Schema.\n\n\n{\n  \"type\": \"string\", \n  \"pattern\": \"^[A-Za-z]*@gmail.com$\"\n}\n\n\n\nHere we are specifying that the email address must end with \n@gmail.com\n, while the part \n[A-Za-z]*\n allows any string consisting of either lower or upper case characters. The symbols \n^\n and \n$\n are used to signify that the matching of a regular expression is done against the entire string. Therefore, the document \n\"adam@gmail.com\"\n validates against the schema above, but \n\"g42s@gmail.com\"\n does not validate, as the first part before the @ contains a character that is not a letter.\n\n\nFor a more detailed introduction to regular expressions we refer the reader to check out the \nRegexOne website\n.\n\n\nFormal Specification\n\n\nString Schemas \nstrSch\n are formally specified using the following grammar.\n\n\n\n\nstrSch\n := \"type\": \"string\" (, \nstrRes\n)\n*\n\n\nstrRes\n :=  \nminLen\n | \nmaxLen\n | \npattern\n\n\nminLen\n := \"minLength\": \nn\n\n\nmaxLen\n := \"maxLength\": \nn\n\n\npattern\n := \"pattern\": \nregExp\n\n\n\n\n\nwhere each \nstrRes\n token appears at most once in \nstrSch\n, n is an arbitrary non-negative integer and r is a regular expression as specified in \nRegexOne website\n.\n\n\nFormal Validation\n\n\nLet \nS\n be a String Schema and \nJ\n a JSON document. We say that \nJ\n validates against \nS\n if for each key:value pair \nk\n in \nS\n one of the following holds:\n\n\n\n\nk\n is \n\"type\":\"string\"\n and \nJ\n is a string\n\n\nk\n is of the form \n\"minLength\" : n\n and \nJ\n is a string of length at least \nn\n\n\nk\n is of the form \n\"maxLength\" : n\n and \nJ\n is a string of length at most \nn\n\n\nk\n is of the form \n\"pattern\" : \"rexp\"\n and \nJ\n is a string that matches the regular expression \nrexp\n\n\n\n\nNote that in the formal definition we don not enforce the keyword \ntype\n to be specified. For instance the Schema\n\n\n{\n  \"minLength\": 3,\n  \"maxLength\": 7\n}\n\n\n\nis well specified and will match any string whose length is between three and seven characters. This is a consequence of the fact that in the absence of explicit type definition we can still infer the base type by parsing other keywords. This behavior is specified in the \nmultiple type\n schemas section. We would, however, like to stress that explicitly specifying the type is a good practice that should always be adhered to.\n\n\nNumeric Schemas\n\n\nAnother form of value in JSON are numbers. In JSON Schema we can \nspecify that a document must be a number by using the \ntype\n keyword. The document\n\n\n{\"type\": \"number\"}\n\n\n\nis a JSON Schema, and validates against any numeric value. For example, values \n34\n and \n1.82\n satisfy \n{\"type\": \"number\"}\n, while \n\"34\"\ndoes not, because it is a string. \n\n\nIf we need to specify that a value must be an integer, we use instead the keyword \ninteger\n:\n\n\n{\"type\": \"integer\"}\n\n\n\nNow the value \n34\n satisfies this schema, but \n1.82\n does not. \n\n\nRestrictions\n\n\nWe can also specify additional constraints that the numbers must satisfy. All of these keywords can be use by either \nnumber\n\nor \ninteger\n types.\n\n\nRange\n\n\nSuppose we need to specify a value for the age of a person, and we want it to be an integer between 0 and 150. We use the \n\n\"minimum\"\n and \n\"maximum\"\n keywords:\n\n{\n   \"type\": \"integer\",\n   \"minimum\": 0,\n   \"maximum\": 150\n }\n\n\nThis document validates against any number between \n0\n and \n150\n.\nBy default the ranges are inclusive: \n\"minimum\": n\n imposes the restriction that numbers need to be \ngreater than or equal to\n \nn\n, and \n\"minimum\": m\n imposes that numbers need to be \nless than or equal to\n \nm\n. This means that both \n0\n and \n150\n satisfy the schema above. We can switch the ranges to be exclusive by using the \n\"exclusiveMinimum\"\n and \n\"exclusiveMaximum\"\n keywords. \n\n\nFor example, the following schema validates against \n0\n, but not against \n150\n:\n\n\n {\n   \"type\":\"integer\", \n   \"minimum\": 0, \n   \"maximum\": 150,\n   \"exclusiveMaximum\":true\n  }\n\n\nIf the \n\"minimum\": n\n keyword is present together with the keyword \n\"exclusiveMinimum\":true\n then the restriction imposes that numbers must be \ngreater\n than \nn\n, and if the \n\"maximum\": m\n keyword is present together with \n\"exclusiveMaximum\":true\n then the restriction is that the number must be \nlower than\n \nm\n. \n\n\nMultiplicity\n\n\nWe can also specify that a number must be the multiple of another number, as in the following schema:\n\n\n {\n   \"type\": \"integer\", \n   \"multipleOf\": 10\n  }\n\nThis schema validates against any number that is a multiple of \n10\n. \nNote that we can also use real numbers in \n\"multipleOf\"\n, and we can combine it with range restrictions. For example, the schema \n\n\n {\n   \"type\":\"integer\", \n   \"multipleOf\": 3.3,\n   \"maximum\": 7\n  }\n\n\nvalidates against numbers \n3.3\n and \n6.6\n.\n\n\nFormal Specification\n\n\nNumeric schemas \nnumSch\n are constructed using the following grammar:\n\n\n\n\nnumSch\n := \"type\": (\"number\" | \"integer\") (, \nnumRes\n)\n*\n\n\nnumRes\n := \nmin\n | \nmax\n | \nmultiple\n \n\nmin\n := \"minimum\": \nr\n (, \nexMin\n)?\n\nexMin\n := \"exclusiveMinimum\": \nbool\n\n\nmax\n := \"maximum\": \nr\n (, \nexMax\n)?\n\nexMax\n := \"exclusiveMaximum\": \nbool\n\n\nmultiple\n := \"multipleOf\": \nr\n (\nr\n\u22650)\n\n\n\n\nwhere each \nnumSch\n can have at most one of each \nmin\n, \nmax\n and \nmultiple\n. Here \nr\n is any positive decimal number, and \nbool\n is either \ntrue\n or \nfalse\n. \n\n\nValidation\n\n\nLet \nN\n be a numeric schema and \nJ\n a JSON document. Then \nN\n validates against \nJ\n if for each name/value pair \nk\n in \nN\n, one of the following holds: \n\n\n\n\nk\n is \n\"type\":\"number\"\n and \nJ\n is a number.\n\n\nk\n is \n\"type\":\"integer\"\n and \nJ\n is an integer number (a number without the decimal \n.\n marker).\n\n\nk\n is \n\"multipleOf\": r\n for some positive decimal number \nr\n, and \nJ\n is a number that is a multpiple of \nr\n.\n\n\nk\n is \n\"minimum\": r\n for some decimal \nr\n, and \nJ\n is a number that is strictly greater than \nr\n.\n\n\nk\n is \n\"minimum\": r\n for some decimal \nr\n,  \nJ\n is a number that is equal to \nr\n and the pair \n\"exclusiveMinimum\": true\n is not in \nN\n.\n\n\nk\n is \n\"maximum\": r\n, for some decimal  \nr\n, and \nJ\n is a number that is stricly less than \nr\n.\n\n\nk\n is \n\"maximum\": r\n for some decimal \nr\n,  \nJ\n is a number that is equal to \nr\n and the pair \n\"exclusiveMinimum\": true\n is not in \nN\n.\n\n\n\n\nBoolean Schemas\n\n\nIn order to specify a property that can be either true or false we use the value type \nboolean\n. A JSON Schema specifying the type \nboolean\n is given below.\n\n\n{\"type\": \"boolean\"}\n\n\n\nThis schema will validate only aginst JSON documents \ntrue\n and \nfalse\n. Any document of diferent form or of different type, such as \n\"true\"\n, \n42\n, or \n\"Number\"\n, will not satsfy the schema. Note that values that usually evaluate to boolean values in programming languages, such as \n0\n and \n1\n are also not permitted.\n\n\nFormal Specification\n\n\nA Boolean Schema \nboolSch\n is formally specified using the following grammar.\n\n\nboolSch\n := \"type\": \"boolean\"\n\n\n\nFormal Validation\n\n\nLet \nB\n be a Boolean Schema and \nJ\n a JSON document. We say that \nJ\n validates against \nB\n if:\n\n\n\n\nJ\n is either \ntrue\n or \nfalse\n\n\n\n\nNull Schemas\n\n\nWhen specifying that a certain value is missing it is usual to use the type \nnull\n. A JSON Schema specifying null values is given below.\n\n\n{\"type\": \"null\"}\n\n\n\nThis schema will validate aginst JSON document \nnull\n and reject all other JSON documents. Therefore documents such as \n\"false\"\n, \nfalse\n or \n0\n will not validate against the schema above.\n\n\nFormal Specification\n\n\nA Schema \nnullSch\n for \nnull\n values is formally specified using the following grammar.\n\n\n\n\nboolSch\n := \"type\": \"null\"\n\n\n\n\nFormal Validation\n\n\nLet \nN\n be a Schema for \nnull\n values and \nJ\n a JSON document. We say that \nJ\n validates against \nN\n if:\n\n\n\n\nJ\n equals \nnull", 
            "title": "Basic Types"
        }, 
        {
            "location": "/spec/basic_types/#basic-types", 
            "text": "JSON Documents can be either basic values (strings, numbers, integers, the boolean constants or null), or ordered or unordered list of key:value pairs. We can use JSON Schema to specify that documents can be any of these. For now we concentrate on the specification for values. There are five basic value types supported by JSON Schema:    string    number     integer  boolean  null", 
            "title": "Basic Types"
        }, 
        {
            "location": "/spec/basic_types/#string-schemas", 
            "text": "One of the most basic forms of values that appear in JSON documents are strings of text. In JSON schema we can specify that a document is a string by using the keyword  string  as the value of the name  type . That is, the document  {\"type\": \"string\"}  is a JSON Schema that valiadates against any JSON that is a string. Note that a JSON document is a string only if it is a sequence of Unicode characters enclosed in double quotation marks. That is,  \"I am a string\"  is a valid JSON document that satisfies the above schema, but so is the sequence  \"42\" , or  \"true\" . On the other hand 42  is a JSON document that will  not  satisfy the above schema, and neither will the document  true .     Restrictions  In order to control the length of our string we can use the keywords  minLength  and  maxLength . To restrict the shape of the string even further we can specify that it conforms to a regular expression using the keyword  pattern .   Restricting the length of a string  We use the  \"minLength\"  and  \"maxLength\"  keywords to specify that the length of a string has to fall into a particular interval. For instance, the following schema  {\n  \"type\": \"string\", \n  \"minLength\": 3,\n  \"maxLength\": 7\n}  specifies that our JSON document is a string whose minimum length is 3 and whose maximum length is 7. The keywords   \"minLength\"  and  \"maxLength\"  always have a non-negative integer as their value. The document  \"This is\"  will validate against the above schema, as it is of length seven. On the other hand  \"Is\" , or  \"This is not valid\"  will not validate against the schema, as the former is too short, while the latter is too long.  Regular expressions  To specify that a string conforms to a regular expression we use the keyword  \"pattern\" . For instance, if we want to enforce that the string is a valid email address with the extension  gmail.com  that contains only letters of the alphabet, we could use the following JSON Schema.  {\n  \"type\": \"string\", \n  \"pattern\": \"^[A-Za-z]*@gmail.com$\"\n}  Here we are specifying that the email address must end with  @gmail.com , while the part  [A-Za-z]*  allows any string consisting of either lower or upper case characters. The symbols  ^  and  $  are used to signify that the matching of a regular expression is done against the entire string. Therefore, the document  \"adam@gmail.com\"  validates against the schema above, but  \"g42s@gmail.com\"  does not validate, as the first part before the @ contains a character that is not a letter.  For a more detailed introduction to regular expressions we refer the reader to check out the  RegexOne website .  Formal Specification  String Schemas  strSch  are formally specified using the following grammar.   strSch  := \"type\": \"string\" (,  strRes ) *  strRes  :=   minLen  |  maxLen  |  pattern  minLen  := \"minLength\":  n  maxLen  := \"maxLength\":  n  pattern  := \"pattern\":  regExp   where each  strRes  token appears at most once in  strSch , n is an arbitrary non-negative integer and r is a regular expression as specified in  RegexOne website .  Formal Validation  Let  S  be a String Schema and  J  a JSON document. We say that  J  validates against  S  if for each key:value pair  k  in  S  one of the following holds:   k  is  \"type\":\"string\"  and  J  is a string  k  is of the form  \"minLength\" : n  and  J  is a string of length at least  n  k  is of the form  \"maxLength\" : n  and  J  is a string of length at most  n  k  is of the form  \"pattern\" : \"rexp\"  and  J  is a string that matches the regular expression  rexp   Note that in the formal definition we don not enforce the keyword  type  to be specified. For instance the Schema  {\n  \"minLength\": 3,\n  \"maxLength\": 7\n}  is well specified and will match any string whose length is between three and seven characters. This is a consequence of the fact that in the absence of explicit type definition we can still infer the base type by parsing other keywords. This behavior is specified in the  multiple type  schemas section. We would, however, like to stress that explicitly specifying the type is a good practice that should always be adhered to.", 
            "title": "String Schemas"
        }, 
        {
            "location": "/spec/basic_types/#numeric-schemas", 
            "text": "Another form of value in JSON are numbers. In JSON Schema we can \nspecify that a document must be a number by using the  type  keyword. The document  {\"type\": \"number\"}  is a JSON Schema, and validates against any numeric value. For example, values  34  and  1.82  satisfy  {\"type\": \"number\"} , while  \"34\" does not, because it is a string.   If we need to specify that a value must be an integer, we use instead the keyword  integer :  {\"type\": \"integer\"}  Now the value  34  satisfies this schema, but  1.82  does not.   Restrictions  We can also specify additional constraints that the numbers must satisfy. All of these keywords can be use by either  number \nor  integer  types.  Range  Suppose we need to specify a value for the age of a person, and we want it to be an integer between 0 and 150. We use the  \"minimum\"  and  \"maximum\"  keywords: {\n   \"type\": \"integer\",\n   \"minimum\": 0,\n   \"maximum\": 150\n }  This document validates against any number between  0  and  150 .\nBy default the ranges are inclusive:  \"minimum\": n  imposes the restriction that numbers need to be  greater than or equal to   n , and  \"minimum\": m  imposes that numbers need to be  less than or equal to   m . This means that both  0  and  150  satisfy the schema above. We can switch the ranges to be exclusive by using the  \"exclusiveMinimum\"  and  \"exclusiveMaximum\"  keywords.   For example, the following schema validates against  0 , but not against  150 :   {\n   \"type\":\"integer\", \n   \"minimum\": 0, \n   \"maximum\": 150,\n   \"exclusiveMaximum\":true\n  }  If the  \"minimum\": n  keyword is present together with the keyword  \"exclusiveMinimum\":true  then the restriction imposes that numbers must be  greater  than  n , and if the  \"maximum\": m  keyword is present together with  \"exclusiveMaximum\":true  then the restriction is that the number must be  lower than   m .   Multiplicity  We can also specify that a number must be the multiple of another number, as in the following schema:   {\n   \"type\": \"integer\", \n   \"multipleOf\": 10\n  } \nThis schema validates against any number that is a multiple of  10 . \nNote that we can also use real numbers in  \"multipleOf\" , and we can combine it with range restrictions. For example, the schema    {\n   \"type\":\"integer\", \n   \"multipleOf\": 3.3,\n   \"maximum\": 7\n  }  validates against numbers  3.3  and  6.6 .  Formal Specification  Numeric schemas  numSch  are constructed using the following grammar:   numSch  := \"type\": (\"number\" | \"integer\") (,  numRes ) *  numRes  :=  min  |  max  |  multiple   min  := \"minimum\":  r  (,  exMin )? exMin  := \"exclusiveMinimum\":  bool  max  := \"maximum\":  r  (,  exMax )? exMax  := \"exclusiveMaximum\":  bool  multiple  := \"multipleOf\":  r  ( r \u22650)  where each  numSch  can have at most one of each  min ,  max  and  multiple . Here  r  is any positive decimal number, and  bool  is either  true  or  false .   Validation  Let  N  be a numeric schema and  J  a JSON document. Then  N  validates against  J  if for each name/value pair  k  in  N , one of the following holds:    k  is  \"type\":\"number\"  and  J  is a number.  k  is  \"type\":\"integer\"  and  J  is an integer number (a number without the decimal  .  marker).  k  is  \"multipleOf\": r  for some positive decimal number  r , and  J  is a number that is a multpiple of  r .  k  is  \"minimum\": r  for some decimal  r , and  J  is a number that is strictly greater than  r .  k  is  \"minimum\": r  for some decimal  r ,   J  is a number that is equal to  r  and the pair  \"exclusiveMinimum\": true  is not in  N .  k  is  \"maximum\": r , for some decimal   r , and  J  is a number that is stricly less than  r .  k  is  \"maximum\": r  for some decimal  r ,   J  is a number that is equal to  r  and the pair  \"exclusiveMinimum\": true  is not in  N .", 
            "title": "Numeric Schemas"
        }, 
        {
            "location": "/spec/basic_types/#boolean-schemas", 
            "text": "In order to specify a property that can be either true or false we use the value type  boolean . A JSON Schema specifying the type  boolean  is given below.  {\"type\": \"boolean\"}  This schema will validate only aginst JSON documents  true  and  false . Any document of diferent form or of different type, such as  \"true\" ,  42 , or  \"Number\" , will not satsfy the schema. Note that values that usually evaluate to boolean values in programming languages, such as  0  and  1  are also not permitted.  Formal Specification  A Boolean Schema  boolSch  is formally specified using the following grammar.  boolSch  := \"type\": \"boolean\"  Formal Validation  Let  B  be a Boolean Schema and  J  a JSON document. We say that  J  validates against  B  if:   J  is either  true  or  false", 
            "title": "Boolean Schemas"
        }, 
        {
            "location": "/spec/basic_types/#null-schemas", 
            "text": "When specifying that a certain value is missing it is usual to use the type  null . A JSON Schema specifying null values is given below.  {\"type\": \"null\"}  This schema will validate aginst JSON document  null  and reject all other JSON documents. Therefore documents such as  \"false\" ,  false  or  0  will not validate against the schema above.  Formal Specification  A Schema  nullSch  for  null  values is formally specified using the following grammar.   boolSch  := \"type\": \"null\"  Formal Validation  Let  N  be a Schema for  null  values and  J  a JSON document. We say that  J  validates against  N  if:   J  equals  null", 
            "title": "Null Schemas"
        }, 
        {
            "location": "/spec/arrays/", 
            "text": "Arrays\n\n\nHere we show how to specify collections of JSON types using possibly nested JSON Schemas.\n\n\nArray Schemas\n\n\nArrays are used to represent ordered sets of values, such as the following sequence of strings:\n\n\n[\"Chilean\", \"Argentinean\", \"Peruvian\", \"Colombian\"]\n\n\n\nIn this section we specify array's main charasteristics and restrictions that may apply to them using a single JSON Schema document.\n\n\nFirst of all, we want to ensure that the document we are validating is an array using the type restriction. This is the basic array schema:\n\n\n{\n \"type\": \"array\"\n}\n\n\n\nThis schema specifyies arrays and no other JSON documents. For example the following document does not validate against the schema:\n\n\n{\n \"nation1\": \"chilean\", \n \"nation2\": \"argentinean\",\n \"this\": \"is\",\n \"not\": \"an\",\n \"keyword\": \"array\"\n }\n\n\n\nOn the other hand, the following JSON does validate against the schema above: \n\n\n[\"Chilean\", \"Argentinean\", \"this\", \"is\", \"an\", \"array\"]\n\n\n\nRestrictions\n\n\nWe can restrict the contents of an array using a JSON Schema. For example, if we want to be sure that the items of the array are strings and that we could have at most \n3\n items we could use the following schema:\n\n\n{\n \"type\": \"array\",\n \"maxItems\": 3,\n \"items\": {\n           \"type\": \"string\"\n          }\n}\n\n\n\nThe following JSON document would validate again the schema:\n\n\n[\"Chilean\", \"Argentinean\"]\n\n\n\nThis one would not validate since it has more than 3 elements:\n\n\n[\"Chilean\", \"Argentinean\", \"Peruvian\", \"Colombian\"]\n\n\n\nA JSON Schema for an array can be seen as set of restrictions that must apply on the elements of the array. In the next sections we specificate each restriction and when a JSON document validates against these restrictions.\n\n\nItem Restriction\n\n\nWe use these restrictions to restrict the elements of the array. We have two ways of doing this. \n\n\nThe first is to enforce that all the elements of an array must validate against a given schema, as in the following example:\n\n\n{\n \"type\": \"array\",\n \"items\":{\n          \"type\": \"integer\"\n         }\n}\n\n\n\nIn this case, we are asking that every element of the array must be an integer. For example, this array validates against the schema\n\n\n[3, 1, 4, 5]\n\n\n\nBut this one does not\n\n\n[3, \"one\", 4, 5]\n\n\n\nThe second way of restricting the elements is to specify a JSON Schema for each element in the array. The following schema is an example of the second use of the items restriction: \n\n\n{\n \"type\": \"array\",\n \"items\" : [{\n          \"type\": \"string\"\n         },\n         {\n          \"type\": \"integer\"\n         },\n         {\n          \"type\": \"boolean\"\n         }\n         ]\n}\n\n\n\nIn this case, we are asking that the first element must be a string, the second one an integer and the third one a boolean. For example, this array validates against the schema\n\n\n[\"Chile\", 1, true ]\n\n\n\nBut this one does not\n\n\n[\"Chile\", \"one\", 4]\n\n\n\nNote that the default behaviour of JSON Schema allows us to have fewer items, as long as the corresponding (sub)schemas are satisfied. For instance, the array \n\n\n[\"Chile\", 4]\n\n\n\ndoes validate against the schema above. The same is true if we have more items. Namely, the following array is valid against the schema above:\n\n\n[\"Chile\", 4, true, \"Argentina\", \"Brazil\"]\n\n\n\nAdditional Items\n\n\nThis restriction specifies if the array can contain items which are not specified in the schema. Here we have an example of this kind of restriction\n\n\n{\n \"type\": \"array\",\n \"items\" : [{\n          \"type\": \"string\"\n         },\n         {\n          \"type\": \"integer\"\n         },\n         {\n          \"type\": \"boolean\"\n         }\n         ],\n \"additionalItems\": false       \n}\n\n\n\nIn this example, we are asking that the first element must be a string, the second one an integer and the third one a boolean. But we cannot have any more items than these three. Here have JSON document that validates against this schema\n\n\n[\"Chile\", 1, true]\n\n\n\nBut this one does not validate, because there is an additional item. \n\n\n[\"Chile\", 1, true, 2]\n\n\n\nAs illustrated above, by default JSON Schema behaves as if the \nadditionalItems\n parameter is set to \ntrue\n.\n\n\nItem Quantity\n\n\nWe can also specify the amount of items in an array. We use \n\"minItems\": n\n to specify that the array must have at least \nn\n elements, and \n\"maxItems\":  n\n to specify that the array cannot have more than \nn\n elements. Here we have an example of this restriction\n\n\n{\n \"type\": \"array\",\n \"minItems\": 2,\n \"maxItems\": 5\n}\n\n\n\nAs we can see, we are specifying arrays with at least \n2\n elements and no more than \n5\n. For example this document validates against the schema\n\n\n[\"Chile\", 16.000.000, \"San Francisco\", 800.000]\n\n\n\nBut this one does not\n\n\n[\"Chile\", 16.000.000, \"San Francisco\", 800.000, \"London\", 9.000.000]\n\n\n\nUniqueness\n\n\nWe use this restriction if we want all elements of an array to be different. The following schema specifies an array in which all documents are different:\n\n\n{\n \"type\": \"array\",\n \"uniqueItems\": true\n}\n\n\n\nFor example this document validates against the schema\n\n\n[1, 3, 5, 7]\n\n\n\nBut this one does not, \n\n\n[1, 3, 5, 3]\n\n\n\nFormal Specification\n\n\nThe correct grammar for these schemas is as follows:\n\n\n \narrSch\n:= \"type\": \"array\" (, \narrRes\n)\n*\n\n\n\n\nHere \narrRes\n is a restriction for the type array such that every \narrRes\n must be different from each other and occurs no more than one time each. Each of these restrictions is defined as follows:\n\n\n \narrRes\n := \nitems\n | \nadditems\n | \nminitems\n | \nmaxitems\n  | \nunique\n\n \nitems\n := ( \nsameitems\n |  \nvaritems\n )\n \nsameitems\n := \"items\": { \nJSch\n }\n \nvaritems\n := \"items\": [{ \nJSch\n }(,{ \nJSch\n })*] \n \nadditems\n :=  \"additionalItems\": (\nbool\n | { \nJSch\n })\n \nminitems\n := \"minItems\": \nn\n\n \nmaxitems\n := \"maxItems\": \nn\n\n \nunique\n := \"uniqueItems\": \nbool\n\n\n\n\nHere \nn\n is a natural number and \nbool\n is either true or false.\n\n\nFormal Validation\n\n\nLet \nA\n be an Array Schema and \nJ\n a JSON document. We say that \nJ\n validates against \nA\n if for each key:value pair \nk\n in \nA\n one of the following holds:\n\n\n\n\nk\n is \n\"items\": S'\n and \nJ\n is an array such that every element validates against S'.\n\n\nk\n is \n\"items\": [s\n1\n , ... , s\nn\n]\n and \nJ\n is an array \n[a\n1\n , ... , a\nm\n]\n such that every element \na\ni\n validates against \ns\ni\n with \ni\n \u2264 Min(m,n).\n\n\nk\n is \n\"additionalItems\": true\n and \nJ\n is an array.\n\n\nk\n is \n\"additionalItems\": false\n, there is a key:value pair \n\"items\": [s\n1\n , ... , s\nn\n]\n in \nA\n and \nJ\n is an array with at most n elements. \n\n\nk\n is \n\"additionalItems\": false\n, and either \nA\n does not contain a pair with keyword \n\"items\"\n, or such pair is of the form \n\"items\": S'\n (that is, the value of items is an object, not an array). \n\n\nk\n is \n\"additionalItems\": S'\n, \nA\n does not contain a pair with keyword \n\"items\"\n and \nJ\n is an array such that every element validates against S'.\n\n\nk\n is \n\"additionalItems\": S'\n and \nA\n contains a pair of the form \n\"items\": S'\n (that is, the value of items is an object, not an array). \n\n\nk\n is \n\"additionalItems\": S'\n, \nA\n has a pair of form \n\"items\": [s\n1\n , ... , s\nn\n]\n, and \nJ\n is an array \n[a\n1\n , ... , a\nm\n]\n such that each a\ni\n, for i \n n, validates against \nS'\n. \n\n\nk\n is \n\"minItems\": n\n and \nJ\n is an array with at least n elements.\n\n\nk\n is \n\"maxItems\": n\n and \nJ\n is an array with at most n elements.\n\n\nk\n is \n\"uniqueItems\": true\n and \nJ\n is an array with all elements different from each other.", 
            "title": "Arrays"
        }, 
        {
            "location": "/spec/arrays/#arrays", 
            "text": "Here we show how to specify collections of JSON types using possibly nested JSON Schemas.", 
            "title": "Arrays"
        }, 
        {
            "location": "/spec/arrays/#array-schemas", 
            "text": "Arrays are used to represent ordered sets of values, such as the following sequence of strings:  [\"Chilean\", \"Argentinean\", \"Peruvian\", \"Colombian\"]  In this section we specify array's main charasteristics and restrictions that may apply to them using a single JSON Schema document.  First of all, we want to ensure that the document we are validating is an array using the type restriction. This is the basic array schema:  {\n \"type\": \"array\"\n}  This schema specifyies arrays and no other JSON documents. For example the following document does not validate against the schema:  {\n \"nation1\": \"chilean\", \n \"nation2\": \"argentinean\",\n \"this\": \"is\",\n \"not\": \"an\",\n \"keyword\": \"array\"\n }  On the other hand, the following JSON does validate against the schema above:   [\"Chilean\", \"Argentinean\", \"this\", \"is\", \"an\", \"array\"]  Restrictions  We can restrict the contents of an array using a JSON Schema. For example, if we want to be sure that the items of the array are strings and that we could have at most  3  items we could use the following schema:  {\n \"type\": \"array\",\n \"maxItems\": 3,\n \"items\": {\n           \"type\": \"string\"\n          }\n}  The following JSON document would validate again the schema:  [\"Chilean\", \"Argentinean\"]  This one would not validate since it has more than 3 elements:  [\"Chilean\", \"Argentinean\", \"Peruvian\", \"Colombian\"]  A JSON Schema for an array can be seen as set of restrictions that must apply on the elements of the array. In the next sections we specificate each restriction and when a JSON document validates against these restrictions.  Item Restriction  We use these restrictions to restrict the elements of the array. We have two ways of doing this.   The first is to enforce that all the elements of an array must validate against a given schema, as in the following example:  {\n \"type\": \"array\",\n \"items\":{\n          \"type\": \"integer\"\n         }\n}  In this case, we are asking that every element of the array must be an integer. For example, this array validates against the schema  [3, 1, 4, 5]  But this one does not  [3, \"one\", 4, 5]  The second way of restricting the elements is to specify a JSON Schema for each element in the array. The following schema is an example of the second use of the items restriction:   {\n \"type\": \"array\",\n \"items\" : [{\n          \"type\": \"string\"\n         },\n         {\n          \"type\": \"integer\"\n         },\n         {\n          \"type\": \"boolean\"\n         }\n         ]\n}  In this case, we are asking that the first element must be a string, the second one an integer and the third one a boolean. For example, this array validates against the schema  [\"Chile\", 1, true ]  But this one does not  [\"Chile\", \"one\", 4]  Note that the default behaviour of JSON Schema allows us to have fewer items, as long as the corresponding (sub)schemas are satisfied. For instance, the array   [\"Chile\", 4]  does validate against the schema above. The same is true if we have more items. Namely, the following array is valid against the schema above:  [\"Chile\", 4, true, \"Argentina\", \"Brazil\"]  Additional Items  This restriction specifies if the array can contain items which are not specified in the schema. Here we have an example of this kind of restriction  {\n \"type\": \"array\",\n \"items\" : [{\n          \"type\": \"string\"\n         },\n         {\n          \"type\": \"integer\"\n         },\n         {\n          \"type\": \"boolean\"\n         }\n         ],\n \"additionalItems\": false       \n}  In this example, we are asking that the first element must be a string, the second one an integer and the third one a boolean. But we cannot have any more items than these three. Here have JSON document that validates against this schema  [\"Chile\", 1, true]  But this one does not validate, because there is an additional item.   [\"Chile\", 1, true, 2]  As illustrated above, by default JSON Schema behaves as if the  additionalItems  parameter is set to  true .  Item Quantity  We can also specify the amount of items in an array. We use  \"minItems\": n  to specify that the array must have at least  n  elements, and  \"maxItems\":  n  to specify that the array cannot have more than  n  elements. Here we have an example of this restriction  {\n \"type\": \"array\",\n \"minItems\": 2,\n \"maxItems\": 5\n}  As we can see, we are specifying arrays with at least  2  elements and no more than  5 . For example this document validates against the schema  [\"Chile\", 16.000.000, \"San Francisco\", 800.000]  But this one does not  [\"Chile\", 16.000.000, \"San Francisco\", 800.000, \"London\", 9.000.000]  Uniqueness  We use this restriction if we want all elements of an array to be different. The following schema specifies an array in which all documents are different:  {\n \"type\": \"array\",\n \"uniqueItems\": true\n}  For example this document validates against the schema  [1, 3, 5, 7]  But this one does not,   [1, 3, 5, 3]  Formal Specification  The correct grammar for these schemas is as follows: \n  arrSch := \"type\": \"array\" (,  arrRes ) *   Here  arrRes  is a restriction for the type array such that every  arrRes  must be different from each other and occurs no more than one time each. Each of these restrictions is defined as follows: \n  arrRes  :=  items  |  additems  |  minitems  |  maxitems   |  unique \n  items  := (  sameitems  |   varitems  )\n  sameitems  := \"items\": {  JSch  }\n  varitems  := \"items\": [{  JSch  }(,{  JSch  })*] \n  additems  :=  \"additionalItems\": ( bool  | {  JSch  })\n  minitems  := \"minItems\":  n \n  maxitems  := \"maxItems\":  n \n  unique  := \"uniqueItems\":  bool   Here  n  is a natural number and  bool  is either true or false.  Formal Validation  Let  A  be an Array Schema and  J  a JSON document. We say that  J  validates against  A  if for each key:value pair  k  in  A  one of the following holds:   k  is  \"items\": S'  and  J  is an array such that every element validates against S'.  k  is  \"items\": [s 1  , ... , s n ]  and  J  is an array  [a 1  , ... , a m ]  such that every element  a i  validates against  s i  with  i  \u2264 Min(m,n).  k  is  \"additionalItems\": true  and  J  is an array.  k  is  \"additionalItems\": false , there is a key:value pair  \"items\": [s 1  , ... , s n ]  in  A  and  J  is an array with at most n elements.   k  is  \"additionalItems\": false , and either  A  does not contain a pair with keyword  \"items\" , or such pair is of the form  \"items\": S'  (that is, the value of items is an object, not an array).   k  is  \"additionalItems\": S' ,  A  does not contain a pair with keyword  \"items\"  and  J  is an array such that every element validates against S'.  k  is  \"additionalItems\": S'  and  A  contains a pair of the form  \"items\": S'  (that is, the value of items is an object, not an array).   k  is  \"additionalItems\": S' ,  A  has a pair of form  \"items\": [s 1  , ... , s n ] , and  J  is an array  [a 1  , ... , a m ]  such that each a i , for i   n, validates against  S' .   k  is  \"minItems\": n  and  J  is an array with at least n elements.  k  is  \"maxItems\": n  and  J  is an array with at most n elements.  k  is  \"uniqueItems\": true  and  J  is an array with all elements different from each other.", 
            "title": "Array Schemas"
        }, 
        {
            "location": "/spec/objects/", 
            "text": "Objects\n\n\nHere we show how to specify collections of key:value pairs using possibly nested JSON Schemas.\n\n\nObject Schemas\n\n\nObjects in JSON are collections of key:value pairs, where the values in these pairs can be again any JSON Document. JSON schemas that specify objects are called \nObject Schemas\n. The document\n\n\n{\"type\": \"object\"}\n\n\n\nis an Object Schema. It specifies any JSON document that is an object, such as \n\n\n{\n  \"first_name\": \"Gary\", \n  \"last_name\": \"Medel\"\n}\n\n\n\nor \n\n\n{\n  \"name\": {\"first_name\": \"Gary\", \"last_name\": \"Medel\"}, \n  \"age\": 27\n}\n\n\n\nbut not, for instance\n\n\n[\"this\",\"is\",\"an\",\"array\"]\n\n\n\nRestrictions\n\n\nJSON Schema contains several keywords allowing us to define more specific types of objects. For example, if we want to specify documents that include \nfirst_name\n, \nlast_name\n and \nage\n, we can use\n\n\n{\n    \"type\": \"object\",\n    \"required\": [\"first_name\", \"last_name\", \"age\"]\n}\n\n\n\nObject types that validate against this schema must have at least pairs with keys \nfirst_name\n, \nlast_name\n and \nage\n. \n\n\nHowever, we have not stated any restrictions for the values of these pairs. This means that the following document also validates against the previous schema: \n\n\n{\n    \"first_name\": 4,\n    \"last_name\": true,\n    \"age\": \"whatever\"\n}\n\n\n\nNot very informative, right? Ideally we would like the values of \nfirst_name\n and \nlast_name\n to be strings and \nage\n to be an integer. We can achieve this as follows: \n\n\n{\n    \"type\": \"object\",\n    \"required\": [\"first_name\", \"last_name\", \"age\"],\n    \"properties\": {\n        \"first_name\": {\"type\": \"string\"},\n        \"last_name\": {\"type\": \"string\"},\n        \"age\": {\"type\": \"integer\"}\n    }\n}\n\n\n\nThis time, the only documents that validate against the schema are those that looke like the following one:\n\n\n{\n    \"first_name\": \"Gary\",\n    \"last_name\": \"Medel\",\n    \"age\": 27\n}\n\n\n\nNext we review all restrictions avaliable for Object Schemas. \n\n\nRequired\n\n\nAs we have mentioned, we use \n\"required\"\n to specify a list of strings that need to be present as key names in the list of \nkey:value\n pairs that appear in a JSON document. In general, a schema of the form \n\n\n{\n    \"type\": \"object\",\n    \"required\": [\"a\", \"b\", \"c\", \"d\"]\n}\n\n\n\nSpecifies documents that need to have pairs with key names \n\"a\"\n, \n\"b\"\n, \n\"c\"\n and \n\"d\"\n. \n\n\nProperties\n\n\nThe \nproperty\n keyword is used to specify the key:value pairs of JSON documents. The value of \nproperty\n is itself a key:value pair, while the value can be any JSON schema and it is used to specify how the value of the key:value pair should look. For example, the following schema specifies that objects should have at least two pairs, with keys \nfirst_name\n and \nlast_name\n, and the values of those must be strings. \n\n\n{\n    \"type\": \"object\",\n    \"required\": [\"first_name\", \"last_name\"],\n    \"properties\": {\n        \"first_name\": {\"type\": \"string\"},\n        \"last_name\": {\"type\": \"string\"}\n    }\n}\n\n\n\nNow let's say that we want to specify football players. They should have a \nname\n, \nage\n and a \nclub_name\n. Furthermore,   the \nname\n should consist of a \nfirst_name\n and a \nlast_name\n. We achieve this using the following schema: \n\n\n{\n    \"type\": \"object\",\n    \"required\": [\"name\", \"age\",\"club_name\"],\n    \"properties\": {\n           \"name\": {\n               \"type\": \"object\",\n               \"required\": [\"first_name\", \"last_name\"],\n               \"properties\": {\n                       \"first_name\": {\"type\": \"string\"},\n                       \"last_name\": {\"type\": \"string\"}\n               }\n           },\n           \"age\": {\"type\": \"integer\"}, \n           \"club_name\": {\"type\": \"string\"}\n    }\n}\n\n\nNote that the schema under \n\"name\"\n is again an Object Schema. We can do this as many times as we want! The following document validates against the schema above\n\n\n\n{\n   \"name\": {\n      \"first_name\": \"Gary\",\n      \"last_name\": \"Medel\"\n   },\n   \"age\": 27,\n   \"club_name\": \"Inter Milan\"\n}\n\n\n\nBy default the names specified under \n\"properties\"\n are not required, this means that, for example, the empty document \n\n\n{}\n\n\n\nvalidates against the schema \n\n\n{\n    \"type\": \"object\",\n    \"properties\": {\n        \"first_name\": {\"type\": \"string\"},\n        \"last_name\": {\"type\": \"string\"}\n    }\n}\n\n\n\nFor validation purproses the \n\"properties\"\n keyword should be understood as follows: if a document contains a key:value pair \nand\n the key of the pair is specified in \n\"properties\"\n, then the value of the pair needs to validate against the schema specified under the key in \n\"properties\"\n. \n\n\nAdditional Properties\n\n\nThe restriction \n\"properties\"\n does not state aything about the structure of any additional names not specified using this keyword. The \n\"additionalProperties\"\n keyword is used both to state if the document will support additional properties from the ones named in \n\"properties\"\n restriction and to give a schema for these extra properties. For example, let us analyze the following schema \n\n\n{\n    \"type\": \"object\",\n    \"properties\": {\n        \"first_name\": {\"type\": \"string\"},\n        \"last_name\": {\"type\": \"string\"}\n    },\n    \"additionalProperties\": false\n}\n\n\n\nIn this case we are asking for documents that do not have any properties whose keywords are different from \n\"first_name\"\n and \n\"last_name\"\n. For instance, this document would not validate:\n\n\n{\n    \"first_name\": \"Gary\",\n    \"last_name\": \"Medel\",\n    \"age\": 25\n}\n\n\n\nThe other use of \n\"additionalProperties\"\n is to restrict the structure of the additional properties of the object. For example, consider the following schema \n\n\n{\n    \"type\": \"object\",\n    \"properties\": {\n        \"first_name\": {\"type\": \"string\"},\n        \"last_name\": {\"type\": \"string\"}\n    },\n    \"additionalProperties\": {\n                             \"type\": \"integer\"\n                            }\n}\n\n\n\nHere we are asking that any keywords different from \n\"first_name\"\n and \n\"last_name\"\n must have integer values. For example the next JSON document validates against the schema\n\n\n{\n    \"first_name\": \"Gary\",\n    \"last_name\": \"Medel\",\n    \"age\": 25\n}\n\n\n\nBut this one does not\n\n\n{\n    \"first_name\": \"Gary\",\n    \"last_name\": \"Medel\",\n    \"age\": \"twenty five\"\n}\n\n\n\nNumber of Properties\n\n\nThe \n\"minProperties\"\nand \n\"maxProperties\"\n keywords are used to restrict the number of properties allowed in a JSON object. For example, let us consider the following schema \n\n\n{\n    \"type\": \"object\",\n    \"minProperties\": 3,\n    \"maxProperties\": 5\n}\n\n\n\nHere we are asking for JSON objects with at least \n3\n properties and no more than \n5\n. For example this object validates against the previous schema\n\n\n{\n    \"first\": 10,\n    \"second\": 11,\n    \"third\": 12,\n    \"four\": 13\n}\n\n\n\nbut this one does not\n\n\n{\n    \"first\": 10,\n    \"second\": 11\n}\n\n\n\nDependencies\n\n\nDependecies are used to modify the schema as a function of the key:value pairs that are present in the JSON document. There are two ways of doing this with the\n\"dependencies\"\n keyword. \n\n\nThe first way is to force the presence of some properties whenever a particular key is present in the document. Let us consider the following example\n\n\n{\n    \"type\": \"object\",\n    \"properties\": {\n        \"first_name\": {\"type\": \"string\"},\n        \"last_name\": {\"type\": \"string\"},\n        \"team\": {\"type\": \"string\"},\n        \"league\": {\"type\": \"string\"}\n            },\n    \"required\": [\"first_name\", \"last_name\"],\n    \"dependencies\": {\n                        \"team\": [\"league\"]    \n                      }\n}\n\n\n\nHere we validate all documents that contain the keys \n\"first_name\"\n and \n\"last_name\"\n, but if the object has the key \n\"team\"\n then the key \n\"league\"\n becomes a required property. For example, this document is valid against the schema\n\n\n{\n    \"first_name\": \"Gary\",\n    \"last_name\": \"Medel\",\n    \"team\": \"Inter Milan\",\n    \"league\": \"Serie A\"\n}\n\n\n\nbut this one is not valid\n\n\n{\n    \"first_name\": \"Gary\",\n    \"last_name\": \"Medel\",\n    \"team\": \"Inter Milan\"\n}\n\n\n\nThe other way of using the \n\"dependencies\"\n keyword is to specify that the JSON object must also satisfy another JSON Schema whenever certain keys are present. Let us consider the following schema as an example\n\n\n{\n    \"type\": \"object\",\n    \"properties\": {\n        \"first_name\": {\"type\": \"string\"},\n        \"last_name\":  {\"type\": \"string\"},\n        \"team\":  {\"type\": \"string\"}\n                     },\n    \"required\": [\"first_name\", \"last_name\"],\n    \"dependencies\":{\n                        \"team\": {\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"league\": {\"type\": \"string\"},\n                            \"goals\": {\"type\": \"integer\"}\n                                         },\n                       \"required\": [\"league\", \"goals\"]\n                        }  \n                      }\n}\n\n\n\nNow JSON objects that do have the key \n\"team\"\n must also validate against the schema \n\n\n\n{\n    \"type\": \"object\",\n    \"properties\": {\n        \"league\": {\"type\": \"string\"},\n        \"goals\": {\"type\": \"integer\"}\n        },\n    \"required\": [\"league\", \"goals\"]\n}\n\n\n\nand thus must also have the keys \n\"league\"\n and \n\"goals\"\n. Note that this is \nnot\n a restriction on the value of the key \nteam\n, but on the document itself. For example the next two objects validate against the complete schema\n\n\n{\n    \"first_name\": \"Gary\",\n    \"last_name\": \"Medel\",\n}\n\n\n\n{\n    \"first_name\": \"Gary\",\n    \"last_name\": \"Medel\",\n    \"team\": \"Inter Milan\",\n    \"league\": \"Serie A\",\n    \"goals\": 5\n}\n\n\n\nBut this one does not\n\n\n{\n    \"first_name\": \"Gary\",\n    \"last_name\": \"Medel\",\n    \"team\": \"Inter Milan\",\n    \"goals\": 5\n}\n\n\n\nNor does\n\n\n{\n    \"first_name\": \"Gary\",\n    \"last_name\": \"Medel\",\n    \"team\": {\n            \"league\": \"Serie A\",\n            \"goals\": 5\n             }\n}\n\n\n\nPattern Properties\n\n\nSometimes we want to restrict a set of properties depending if they share a pattern on their keys. The \n\"patternProperties\"\n keyword is used to restrict keywords matching a certain regular expression. Let us see an example of this\n\n\n{\n    \"type\": \"object\",\n    \"properties\": {\n        \"first_name\": {\"type\": \"string\"},\n        \"last_name\": {\"type\": \"string\"},\n        \"team\": {\"type\": \"string\"},\n        \"league\": {\"type\": \"string\"}\n            },\n   \"patternProperties\": {\n       \"_goals$\": { \"type\": \"integer\" }\n  }\n}\n\n\n\nHere we are asking that keys matching the regular expression  \n_goals$\n must be integers. For example the following JSON object validates against the schema\n\n\n{\n    \"first_name\": \"Gary\",\n    \"last_name\": \"Medel\",\n    \"team\": \"Inter de Milan\",\n    \"league\": \"Serie A\",\n    \"league_goals\": 5,\n    \"international_goals\": 2\n}\n\n\n\nbut this one does not\n\n\n{\n    \"first_name\": \"Gary\",\n    \"last_name\": \"Medel\",\n    \"team\": \"Inter Milan\",\n    \"league\": \"Serie A\",\n    \"league_goals\": \"five\"\n}\n\n\n\nFormal Specification\n\n\nThe correct grammar for these schemmas can be seen like this:\n\n\n\n \nobjSch\n:= \"type\": \"object\" (, \nobjRes\n)\n*\n\n\n\n\n\nHere \nobjRes\n is a restriction for objects such that every \nobjRes\n occurence in the schema is unique. Each of these restrictions is defined as follows:\n\n\n\n\nobjRes\n := \nprop\n | \naddprop\n | \nreq\n | \nminprop\n | \nmaxprop\n | \ndep\n | \npattprop\n\n\nprop\n := \"properties\": { \nkSch\n (, \nkSch\n)*}\n\nkSch\n := \nkword\n: { \nJSch\n }\n\naddprop\n := \"additionalProperties\": (\nbool\n | { \nJSch\n })\n\nreq\n := \"required\": [ \nkword\n (, \nkword\n)*]\n\nminprop\n := \"minProperties\": \nn\n\n\nmaxprop\n := \"maxProperties\": \nn\n\n\ndep\n := \"dependencies\": { \nkDep\n (, \nkDep\n)*}\n\nkDep\n := (\nkArr\n | \nkSch\n)\n\nkArr\n := \nkword\n: [ \nkword\n (, \nkword\n)*]\n\npattprop\n := \"patternProperties\": { \npatSch\n (, \npatSch\n)*}\n\npatSch\n := \"\nregExp\n\": { \nJSch\n }\n\n\n\n\nHere \nn\n is a natural number, \nbool\n is either true or false and \nregExp\n is a regular expression. Furthermore, \nkword\n is a JSON string and \nJSch\n a JSON Schema. \n\n\nFormal Validation\n\n\nLet \nO\n be an object Schema and \nJ\n a JSON document. We say that a keyword \nk\n appears in \nJ\n is \nJ\n contains a key:value pair of the form \nk: j'\n, for some document \nj'\n. Moreover, we use \nproperties(O)\n to denote all keywords \nk\n1\n, ..., k\nn\n that appear in the key-value pair of the form \n\"properties\": {k\n1\n: s\n1\n , ... , k\nn\n: s\nn\n}\n in \nO\n. The set \nproperties(O)\n is empty if the keyword properties does not appear in \nO\n. Likewise, we use \npatternProperties(O)\n to denote all keywords \nk\n1\n, ..., k\nn\n that appear in the key-value pair of the form  \n\"additionalProperties\": {k\n1\n: s\n1\n , ... , k\nn\n: s\nn\n}\n in \nO\n. The set \n patternProperties(O)\n is empty if the keyword \npatternProperties\n does not appear in \nO\n.\n\n\nWe say that \nJ\n validates against \nO\n if for each key:value pair \nk\n in \nO\n one of the following holds:\n\n\n\n\nk\n is of the form \n\"type\": \"object\"\n and \nJ\n is an object\n\n\nk\n is of the form \n\"properties\": {k\n1\n: s\n1\n , ... , k\nn\n: s\nn\n}\n and \nJ\n is an object that for each key-value pair \nk': j'\n in \nJ\n, if \nk' = k\ni\n for some \ni\n in [ \n1\n , ... , \nn\n ] then \nj'\n satisfies \ns\ni\n.\n\n\nk\n is of the form \n\"patternProperties\": {rexp\n1\n: s\n1\n , ... , rexp\nn\n: s\nn\n}\n and \nJ\n is an object such that for each key-value pair \nk': j'\n in \nJ\n and \nevery rexp\ni\n, i in [ \n1\n , ... , \nn\n ], such that \nk'\n is in the language of rexp\ni\n, then \n\nj'\n satisfies \ns\ni\n.\n\n\nk\n is of the form \n\"required\": [k\n1\n , ... , k\nn\n]\n and each \nk\ni\n appears in \nJ\n. \n\n\nk\n is of the form \n\"minProperties\": n\n and \nJ\n is an object with at least \nn\n key:value pairs.\n\n\nk\n is of the form \n\"maxProperties\": n\n and \nJ\n is an object with at most \nn\n key:value pairs.\n\n\nk\n is of the form \n\"additionalProperties\": false\n and \nJ\n is an object such that every keyword in \nJ\n either belongs to \nproperties(O)\n or matches at least one of the expressions in \npatternProperties(O)\n\n\nk\n is of the form \n\"additionalProperties\": true\n and \nJ\n is an object\n\n\nk\n is of the form \n\"additionalProperties\": S'\n and \nJ\n is an object such that for each key-value pair \nk': j'\n in \nJ\n, with \nk'\n not in \nproperties(O)\n and \nk'\n not matching any of the expressions in \npatternProperties(O)\n, we have that \nj'\n validates against \nS'\n\n\nk\n is of the form \n\"dependencies\": {k\n1\n: [l\n1,1\n , ... ,l\n1,m\n1\n], ... , k\nn\n: [l\nn,1\n , ... ,l\nn,m\nn\n]}\n and \nJ\n is an object such that if \nk\ni\n appears in \nJ\n then every keyword in \n[l\ni,1\n , ... ,l\ni,m\ni\n]\n appears in \nJ\n\n\nk\n is of the form \n\"dependencies\": {k\n1\n: s\n1\n , ... , k\nn\n: s\nn\n}\n  and \nJ\n is an object such that if \nk\ni\n appears in \nJ\n then \nJ\n must satisfy \ns\ni", 
            "title": "Objects"
        }, 
        {
            "location": "/spec/objects/#objects", 
            "text": "Here we show how to specify collections of key:value pairs using possibly nested JSON Schemas.", 
            "title": "Objects"
        }, 
        {
            "location": "/spec/objects/#object-schemas", 
            "text": "Objects in JSON are collections of key:value pairs, where the values in these pairs can be again any JSON Document. JSON schemas that specify objects are called  Object Schemas . The document  {\"type\": \"object\"}  is an Object Schema. It specifies any JSON document that is an object, such as   {\n  \"first_name\": \"Gary\", \n  \"last_name\": \"Medel\"\n}  or   {\n  \"name\": {\"first_name\": \"Gary\", \"last_name\": \"Medel\"}, \n  \"age\": 27\n}  but not, for instance  [\"this\",\"is\",\"an\",\"array\"]  Restrictions  JSON Schema contains several keywords allowing us to define more specific types of objects. For example, if we want to specify documents that include  first_name ,  last_name  and  age , we can use  {\n    \"type\": \"object\",\n    \"required\": [\"first_name\", \"last_name\", \"age\"]\n}  Object types that validate against this schema must have at least pairs with keys  first_name ,  last_name  and  age .   However, we have not stated any restrictions for the values of these pairs. This means that the following document also validates against the previous schema:   {\n    \"first_name\": 4,\n    \"last_name\": true,\n    \"age\": \"whatever\"\n}  Not very informative, right? Ideally we would like the values of  first_name  and  last_name  to be strings and  age  to be an integer. We can achieve this as follows:   {\n    \"type\": \"object\",\n    \"required\": [\"first_name\", \"last_name\", \"age\"],\n    \"properties\": {\n        \"first_name\": {\"type\": \"string\"},\n        \"last_name\": {\"type\": \"string\"},\n        \"age\": {\"type\": \"integer\"}\n    }\n}  This time, the only documents that validate against the schema are those that looke like the following one:  {\n    \"first_name\": \"Gary\",\n    \"last_name\": \"Medel\",\n    \"age\": 27\n}  Next we review all restrictions avaliable for Object Schemas.   Required  As we have mentioned, we use  \"required\"  to specify a list of strings that need to be present as key names in the list of  key:value  pairs that appear in a JSON document. In general, a schema of the form   {\n    \"type\": \"object\",\n    \"required\": [\"a\", \"b\", \"c\", \"d\"]\n}  Specifies documents that need to have pairs with key names  \"a\" ,  \"b\" ,  \"c\"  and  \"d\" .   Properties  The  property  keyword is used to specify the key:value pairs of JSON documents. The value of  property  is itself a key:value pair, while the value can be any JSON schema and it is used to specify how the value of the key:value pair should look. For example, the following schema specifies that objects should have at least two pairs, with keys  first_name  and  last_name , and the values of those must be strings.   {\n    \"type\": \"object\",\n    \"required\": [\"first_name\", \"last_name\"],\n    \"properties\": {\n        \"first_name\": {\"type\": \"string\"},\n        \"last_name\": {\"type\": \"string\"}\n    }\n}  Now let's say that we want to specify football players. They should have a  name ,  age  and a  club_name . Furthermore,   the  name  should consist of a  first_name  and a  last_name . We achieve this using the following schema:   {\n    \"type\": \"object\",\n    \"required\": [\"name\", \"age\",\"club_name\"],\n    \"properties\": {\n           \"name\": {\n               \"type\": \"object\",\n               \"required\": [\"first_name\", \"last_name\"],\n               \"properties\": {\n                       \"first_name\": {\"type\": \"string\"},\n                       \"last_name\": {\"type\": \"string\"}\n               }\n           },\n           \"age\": {\"type\": \"integer\"}, \n           \"club_name\": {\"type\": \"string\"}\n    }\n}  Note that the schema under  \"name\"  is again an Object Schema. We can do this as many times as we want! The following document validates against the schema above  \n{\n   \"name\": {\n      \"first_name\": \"Gary\",\n      \"last_name\": \"Medel\"\n   },\n   \"age\": 27,\n   \"club_name\": \"Inter Milan\"\n}  By default the names specified under  \"properties\"  are not required, this means that, for example, the empty document   {}  validates against the schema   {\n    \"type\": \"object\",\n    \"properties\": {\n        \"first_name\": {\"type\": \"string\"},\n        \"last_name\": {\"type\": \"string\"}\n    }\n}  For validation purproses the  \"properties\"  keyword should be understood as follows: if a document contains a key:value pair  and  the key of the pair is specified in  \"properties\" , then the value of the pair needs to validate against the schema specified under the key in  \"properties\" .   Additional Properties  The restriction  \"properties\"  does not state aything about the structure of any additional names not specified using this keyword. The  \"additionalProperties\"  keyword is used both to state if the document will support additional properties from the ones named in  \"properties\"  restriction and to give a schema for these extra properties. For example, let us analyze the following schema   {\n    \"type\": \"object\",\n    \"properties\": {\n        \"first_name\": {\"type\": \"string\"},\n        \"last_name\": {\"type\": \"string\"}\n    },\n    \"additionalProperties\": false\n}  In this case we are asking for documents that do not have any properties whose keywords are different from  \"first_name\"  and  \"last_name\" . For instance, this document would not validate:  {\n    \"first_name\": \"Gary\",\n    \"last_name\": \"Medel\",\n    \"age\": 25\n}  The other use of  \"additionalProperties\"  is to restrict the structure of the additional properties of the object. For example, consider the following schema   {\n    \"type\": \"object\",\n    \"properties\": {\n        \"first_name\": {\"type\": \"string\"},\n        \"last_name\": {\"type\": \"string\"}\n    },\n    \"additionalProperties\": {\n                             \"type\": \"integer\"\n                            }\n}  Here we are asking that any keywords different from  \"first_name\"  and  \"last_name\"  must have integer values. For example the next JSON document validates against the schema  {\n    \"first_name\": \"Gary\",\n    \"last_name\": \"Medel\",\n    \"age\": 25\n}  But this one does not  {\n    \"first_name\": \"Gary\",\n    \"last_name\": \"Medel\",\n    \"age\": \"twenty five\"\n}  Number of Properties  The  \"minProperties\" and  \"maxProperties\"  keywords are used to restrict the number of properties allowed in a JSON object. For example, let us consider the following schema   {\n    \"type\": \"object\",\n    \"minProperties\": 3,\n    \"maxProperties\": 5\n}  Here we are asking for JSON objects with at least  3  properties and no more than  5 . For example this object validates against the previous schema  {\n    \"first\": 10,\n    \"second\": 11,\n    \"third\": 12,\n    \"four\": 13\n}  but this one does not  {\n    \"first\": 10,\n    \"second\": 11\n}  Dependencies  Dependecies are used to modify the schema as a function of the key:value pairs that are present in the JSON document. There are two ways of doing this with the \"dependencies\"  keyword.   The first way is to force the presence of some properties whenever a particular key is present in the document. Let us consider the following example  {\n    \"type\": \"object\",\n    \"properties\": {\n        \"first_name\": {\"type\": \"string\"},\n        \"last_name\": {\"type\": \"string\"},\n        \"team\": {\"type\": \"string\"},\n        \"league\": {\"type\": \"string\"}\n            },\n    \"required\": [\"first_name\", \"last_name\"],\n    \"dependencies\": {\n                        \"team\": [\"league\"]    \n                      }\n}  Here we validate all documents that contain the keys  \"first_name\"  and  \"last_name\" , but if the object has the key  \"team\"  then the key  \"league\"  becomes a required property. For example, this document is valid against the schema  {\n    \"first_name\": \"Gary\",\n    \"last_name\": \"Medel\",\n    \"team\": \"Inter Milan\",\n    \"league\": \"Serie A\"\n}  but this one is not valid  {\n    \"first_name\": \"Gary\",\n    \"last_name\": \"Medel\",\n    \"team\": \"Inter Milan\"\n}  The other way of using the  \"dependencies\"  keyword is to specify that the JSON object must also satisfy another JSON Schema whenever certain keys are present. Let us consider the following schema as an example  {\n    \"type\": \"object\",\n    \"properties\": {\n        \"first_name\": {\"type\": \"string\"},\n        \"last_name\":  {\"type\": \"string\"},\n        \"team\":  {\"type\": \"string\"}\n                     },\n    \"required\": [\"first_name\", \"last_name\"],\n    \"dependencies\":{\n                        \"team\": {\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"league\": {\"type\": \"string\"},\n                            \"goals\": {\"type\": \"integer\"}\n                                         },\n                       \"required\": [\"league\", \"goals\"]\n                        }  \n                      }\n}  Now JSON objects that do have the key  \"team\"  must also validate against the schema   \n{\n    \"type\": \"object\",\n    \"properties\": {\n        \"league\": {\"type\": \"string\"},\n        \"goals\": {\"type\": \"integer\"}\n        },\n    \"required\": [\"league\", \"goals\"]\n}  and thus must also have the keys  \"league\"  and  \"goals\" . Note that this is  not  a restriction on the value of the key  team , but on the document itself. For example the next two objects validate against the complete schema  {\n    \"first_name\": \"Gary\",\n    \"last_name\": \"Medel\",\n}  {\n    \"first_name\": \"Gary\",\n    \"last_name\": \"Medel\",\n    \"team\": \"Inter Milan\",\n    \"league\": \"Serie A\",\n    \"goals\": 5\n}  But this one does not  {\n    \"first_name\": \"Gary\",\n    \"last_name\": \"Medel\",\n    \"team\": \"Inter Milan\",\n    \"goals\": 5\n}  Nor does  {\n    \"first_name\": \"Gary\",\n    \"last_name\": \"Medel\",\n    \"team\": {\n            \"league\": \"Serie A\",\n            \"goals\": 5\n             }\n}  Pattern Properties  Sometimes we want to restrict a set of properties depending if they share a pattern on their keys. The  \"patternProperties\"  keyword is used to restrict keywords matching a certain regular expression. Let us see an example of this  {\n    \"type\": \"object\",\n    \"properties\": {\n        \"first_name\": {\"type\": \"string\"},\n        \"last_name\": {\"type\": \"string\"},\n        \"team\": {\"type\": \"string\"},\n        \"league\": {\"type\": \"string\"}\n            },\n   \"patternProperties\": {\n       \"_goals$\": { \"type\": \"integer\" }\n  }\n}  Here we are asking that keys matching the regular expression   _goals$  must be integers. For example the following JSON object validates against the schema  {\n    \"first_name\": \"Gary\",\n    \"last_name\": \"Medel\",\n    \"team\": \"Inter de Milan\",\n    \"league\": \"Serie A\",\n    \"league_goals\": 5,\n    \"international_goals\": 2\n}  but this one does not  {\n    \"first_name\": \"Gary\",\n    \"last_name\": \"Medel\",\n    \"team\": \"Inter Milan\",\n    \"league\": \"Serie A\",\n    \"league_goals\": \"five\"\n}  Formal Specification  The correct grammar for these schemmas can be seen like this:  \n  objSch := \"type\": \"object\" (,  objRes ) *   Here  objRes  is a restriction for objects such that every  objRes  occurence in the schema is unique. Each of these restrictions is defined as follows:   objRes  :=  prop  |  addprop  |  req  |  minprop  |  maxprop  |  dep  |  pattprop  prop  := \"properties\": {  kSch  (,  kSch )*} kSch  :=  kword : {  JSch  } addprop  := \"additionalProperties\": ( bool  | {  JSch  }) req  := \"required\": [  kword  (,  kword )*] minprop  := \"minProperties\":  n  maxprop  := \"maxProperties\":  n  dep  := \"dependencies\": {  kDep  (,  kDep )*} kDep  := ( kArr  |  kSch ) kArr  :=  kword : [  kword  (,  kword )*] pattprop  := \"patternProperties\": {  patSch  (,  patSch )*} patSch  := \" regExp \": {  JSch  }  Here  n  is a natural number,  bool  is either true or false and  regExp  is a regular expression. Furthermore,  kword  is a JSON string and  JSch  a JSON Schema.   Formal Validation  Let  O  be an object Schema and  J  a JSON document. We say that a keyword  k  appears in  J  is  J  contains a key:value pair of the form  k: j' , for some document  j' . Moreover, we use  properties(O)  to denote all keywords  k 1 , ..., k n  that appear in the key-value pair of the form  \"properties\": {k 1 : s 1  , ... , k n : s n }  in  O . The set  properties(O)  is empty if the keyword properties does not appear in  O . Likewise, we use  patternProperties(O)  to denote all keywords  k 1 , ..., k n  that appear in the key-value pair of the form   \"additionalProperties\": {k 1 : s 1  , ... , k n : s n }  in  O . The set   patternProperties(O)  is empty if the keyword  patternProperties  does not appear in  O .  We say that  J  validates against  O  if for each key:value pair  k  in  O  one of the following holds:   k  is of the form  \"type\": \"object\"  and  J  is an object  k  is of the form  \"properties\": {k 1 : s 1  , ... , k n : s n }  and  J  is an object that for each key-value pair  k': j'  in  J , if  k' = k i  for some  i  in [  1  , ... ,  n  ] then  j'  satisfies  s i .  k  is of the form  \"patternProperties\": {rexp 1 : s 1  , ... , rexp n : s n }  and  J  is an object such that for each key-value pair  k': j'  in  J  and \nevery rexp i , i in [  1  , ... ,  n  ], such that  k'  is in the language of rexp i , then  j'  satisfies  s i .  k  is of the form  \"required\": [k 1  , ... , k n ]  and each  k i  appears in  J .   k  is of the form  \"minProperties\": n  and  J  is an object with at least  n  key:value pairs.  k  is of the form  \"maxProperties\": n  and  J  is an object with at most  n  key:value pairs.  k  is of the form  \"additionalProperties\": false  and  J  is an object such that every keyword in  J  either belongs to  properties(O)  or matches at least one of the expressions in  patternProperties(O)  k  is of the form  \"additionalProperties\": true  and  J  is an object  k  is of the form  \"additionalProperties\": S'  and  J  is an object such that for each key-value pair  k': j'  in  J , with  k'  not in  properties(O)  and  k'  not matching any of the expressions in  patternProperties(O) , we have that  j'  validates against  S'  k  is of the form  \"dependencies\": {k 1 : [l 1,1  , ... ,l 1,m 1 ], ... , k n : [l n,1  , ... ,l n,m n ]}  and  J  is an object such that if  k i  appears in  J  then every keyword in  [l i,1  , ... ,l i,m i ]  appears in  J  k  is of the form  \"dependencies\": {k 1 : s 1  , ... , k n : s n }   and  J  is an object such that if  k i  appears in  J  then  J  must satisfy  s i", 
            "title": "Object Schemas"
        }, 
        {
            "location": "/spec/generic_keywords/", 
            "text": "Generic Keywords\n\n\nJSON Schemas also support keywords that may apply to any JSON type. In this section we provide the correct use and syntax of these keywords.\n\n\nCombined Restrictions\n\n\nSometimes we want to specify more complex constraints that require verifying if a document validates against multiple schemas. JSON Schema allows us to do so using the following keywords: \n\n\n\n\nanyOf\n, which forces the document to validate against \nat least one\n of the specified schemas\n\n\nallOf\n, which forces the document to validate against \nall\n of the specified schemas\n\n\noneOf\n, which forces the document to validate against \nprecisely one\n of the specified schemas.\n\n\n\n\nAdditionally, we can use:\n\n\n\n\nnot\n, which states that a document does \nnot\n validate against a specified schema.  \n\n\n\n\nBelow we describe each of the keywords in more detail.\n\n\nanyOf\n\n\nThe \n\"anyOf\"\n keyword is used to make  document validate against at least one of the listed schemas. For instance, if we were building an application that can accept either strings or integers we could use the following schema to check if the document is of the correct format.\n\n\n{\n  \"anyOf\": [\n    { \"type\": \"string\" }, \n    { \"type\": \"integer\" }\n  ]\n}\n\n\n\n\nIn this case JSON document \n\"This is a string\"\n satisfies the above schema, as does the document \n72\n. On the other hand \n7.42\n does not satisfy the schema, nor does the document \n{ \"name\": \"Gary\"}\n.\n\n\nallOf\n\n\nIn order to specify that our document has to conform to several different schemas we use the keyword \n\"allOf\"\n. For instance if we want to accept strings that are in the intersection of two regular expressions it is often simpler to validate against two different schemas than write a single regular expression denoting the intersection. The schema below validates against any string that is a gmail address and that contains a substring \n\"joe\"\n.\n\n\n{\n  \"allOf\": [\n    { \"type\": \"string\", \"pattern\": \"^.+@gmail.com$\" }, \n    { \"type\": \"string\", \"pattern\": \"^.*joe.*$\" }\n  ]\n}\n\n\n\n\nAlthough the example above looks somewhat superficial (and is indeed expressible without using the \n\"allOf\"\n keyword, as all basic examples of \n\"allOf\"\n are), the true usefulness of the \n\"allOf\"\n keyword becomes evident when combined with the \n\"definition\"\n and \n\"$ref\"\n keywords.\n\n\nNote that using \n\"allOf\"\n one can easily define schemas that do \nnot\n validate against any document. For instance the schema below requires the document to be both a string and an integer, which is clearly not possible.\n\n\n{\n  \"allOf\": [\n    { \"type\": \"string\" }, \n    { \"type\": \"integer\" }\n  ]\n}\n\n\n\n\noneOf\n\n\nWhen we want to validate against precisely one schema from a predefined set of schemas we use the \n\"oneOf\"\n keyword. For instance if want to find numbers that are multiples of \n2\n or multiples of \n5\n, but not both at the same time we could use the following schema.\n\n\n{\n  \"oneOf\": [\n    { \"type\": \"integer\", \"multipleOf\": 2 }, \n    { \"type\": \"integer\", \"multipleOf\": 5}\n  ]\n}\n\n\n\n\nThis schema validates against \n4\n and \n15\n, but it does not validate against \n10\n, as it satisfies both of the schemas. Equally, the schema does not validate against \n3\n, or any document that is not an integer.\n\n\nnot\n\n\nTo say that a document does not validate against a certain schema we use the \n\"not\"\n keyword. For instance the schema below validates against any document that is not a string.\n\n\n{ \"not\": { \"type\": \"string\" } }  \n\n\n\n\nIt accepts the document \n4\n or \n{ \"name\": \"Gary\" }\n, but not \n\"name\"\n, or any other string.  \n\n\nFormal Specification\n\n\nCombined restrictions \ncombRes\n are formally specified using the following grammar.\n\n\n\n\ncombRes\n := \nallOf\n | \nanyOf\n| \noneOf\n | \nnot\n\n\nanyOf\n := \"anyOf\": [ { \nJSch\n } (, { \nJSch\n })* ]\n\nallOf\n := \"allOf\": [ { \nJSch\n } (, { \nJSch\n })* ]\n\noneOf\n := \"oneOf\": [ { \nJSch\n } (, { \nJSch\n })* ]\n\nnot\n := \"not\": { \nJSch\n }\n\n\n\n\nwhere \nJSch\n denotes an arbitrary JSON Schema.\n\n\nFormal Validation\n\n\nLet \nC\n be a Combined Restriction and \nJ\n a JSON document. We say that \nJ\n validates against \nC\n if:\n\n\n\n\nC\n is of the form \n\"anyOf\": [{Sch\n1\n}, {Sch\n2\n}, ... ,{Sch\nn\n}]\n and \nJ\n conforms to \nsome\n \nSch\ni\n, for \ni\n=\n1\n...\nn\n\n\nC\n is of the form \n\"allOf\": [{Sch\n1\n}, {Sch\n2\n}, ... ,{Sch\nn\n}]\n and \nJ\n conforms to \nall\n of \nSch\ni\n, for \ni\n=\n1\n...\nn\n\n\nC\n is of the form \n\"oneOf\": [{Sch\n1\n}, {Sch\n2\n}, ... ,{Sch\nn\n}]\n and \nJ\n conforms to \nexactly one\n of \nSch\ni\n, for \ni\n=\n1\n...\nn\n\n\nC\n is of the form \n\"not\": {Sch}\n and \nJ\n does \nnot\n validate against \nSch\n.\n\n\n\n\nEnumerated Values\n\n\nThe \n\"enum\"\n keyword restricts JSON instances to have certain values specified in an array following the keyword. Let's take a look the following example:\n\n\n{\n \"type\": \"string\",\n \"enum\": [\"Inter Milan\", \"AC Milan\", \"Juventus\", \"Roma\"]\n}\n\n\n\nHere we are asking for JSON strings with the values \n\"Inter Milan\"\n, \n\"AC Milan\"\n, \n\"Juventus\"\n or \n\"Roma\"\n. Apart from these, no other JSON string will be validated against the schema. For example the following JSON instance validates against the schema\n\n\n\"AC Milan\"\n\n\n\nBut this one does not\n\n\n\"Fiorentina\"\n\n\n\nThe \nenum\n keyword also allows us have different types in the list of allowed values. Consider the schema:\n\n\n{\n \"enum\": [\"Two\", 2, true, null]\n}\n\n\n\nThen the following JSON validates against the  schema:\n\n\nnull\n\n\n\nBut this one does not:\n\n\n16\n\n\n\nFormal Specification\n\n\nThe \n\"enum\"\n restriction is formally specified using the following grammar.\n\n\n\n\nenum\n := \"enum\": [\nJval\n (, \nJval\n)\n*\n]\n\n\n\n\nWhere \nJval\n can be either a \nnumber\n, a \nstring\n, an \nobject\n, an \narray\n, a \nboolean\n or a \nnull\n value. Note that each \nJval\n must be different from the the other values appearing in the array.\n\n\nFormal Validation\n\n\nLet \nS\n be Schema and \nJ\n a JSON document. We say that \nJ\n validates against \nS\n if the following holds:\n\n\n\n\nS\n has the restriction \n\"enum\": [val\n1\n , ... , val\nn]\n and \nJ\n equals \nval\ni\n for some \ni\n in [ \n1\n , ..., \nn\n ].\n\n\n\n\nMetadata\n\n\nThe following group of keywords represent metadata of the schema and does not have a very strong semantic. However, it is a good practice both for programmers and users to provide this information. These keywords can be either \n\"title\"\n, \n\"description\"\n, \n\"default\"\n or \n\"$schema\"\n. Let us take a look to the following example\n\n\n{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"Player schema\",\n    \"description\": \"This schema accepts soccer players\",\n    \"default\": null,\n    \"type\": \"object\",\n    \"properties\": {\n        \"first_name\": { \"type\": \"string\" },\n        \"last_name\": { \"type\": \"string\" },\n        \"age\": { \"type\": \"integer\" },\n        \"club\": {\n            \"type\": \"object\",\n            \"properties\": {\n                \"name\": { \"type\": \"string\" },\n                \"founded\": { \"type\": \"integer\" }\n            },\n            \"required\": [\"name\"]\n        }\n    },\n    \"required\": [\"first_name\", \"last_name\", \"age\", \"club\"]\n}\n\n\n\nFirst, the \n\"$schema\"\n keyword specifies that the current schema follows the specification of the version 3 of JSON Schema. We can provide different versions deppending of our requirements. The \n\"title\"\n keyword is useful to give a name to the schema. Similarly, the \n\"description\"\n keyword is useful to give a short description of what kind of documents the schema accepts. Finally the \n\"default\"\n keyword can be used to specify a default value for the document if a hipothetical validator reads a missing value as input.", 
            "title": "Generic Keywords"
        }, 
        {
            "location": "/spec/generic_keywords/#generic-keywords", 
            "text": "JSON Schemas also support keywords that may apply to any JSON type. In this section we provide the correct use and syntax of these keywords.", 
            "title": "Generic Keywords"
        }, 
        {
            "location": "/spec/generic_keywords/#combined-restrictions", 
            "text": "Sometimes we want to specify more complex constraints that require verifying if a document validates against multiple schemas. JSON Schema allows us to do so using the following keywords:    anyOf , which forces the document to validate against  at least one  of the specified schemas  allOf , which forces the document to validate against  all  of the specified schemas  oneOf , which forces the document to validate against  precisely one  of the specified schemas.   Additionally, we can use:   not , which states that a document does  not  validate against a specified schema.     Below we describe each of the keywords in more detail.  anyOf  The  \"anyOf\"  keyword is used to make  document validate against at least one of the listed schemas. For instance, if we were building an application that can accept either strings or integers we could use the following schema to check if the document is of the correct format.  {\n  \"anyOf\": [\n    { \"type\": \"string\" }, \n    { \"type\": \"integer\" }\n  ]\n}  In this case JSON document  \"This is a string\"  satisfies the above schema, as does the document  72 . On the other hand  7.42  does not satisfy the schema, nor does the document  { \"name\": \"Gary\"} .  allOf  In order to specify that our document has to conform to several different schemas we use the keyword  \"allOf\" . For instance if we want to accept strings that are in the intersection of two regular expressions it is often simpler to validate against two different schemas than write a single regular expression denoting the intersection. The schema below validates against any string that is a gmail address and that contains a substring  \"joe\" .  {\n  \"allOf\": [\n    { \"type\": \"string\", \"pattern\": \"^.+@gmail.com$\" }, \n    { \"type\": \"string\", \"pattern\": \"^.*joe.*$\" }\n  ]\n}  Although the example above looks somewhat superficial (and is indeed expressible without using the  \"allOf\"  keyword, as all basic examples of  \"allOf\"  are), the true usefulness of the  \"allOf\"  keyword becomes evident when combined with the  \"definition\"  and  \"$ref\"  keywords.  Note that using  \"allOf\"  one can easily define schemas that do  not  validate against any document. For instance the schema below requires the document to be both a string and an integer, which is clearly not possible.  {\n  \"allOf\": [\n    { \"type\": \"string\" }, \n    { \"type\": \"integer\" }\n  ]\n}  oneOf  When we want to validate against precisely one schema from a predefined set of schemas we use the  \"oneOf\"  keyword. For instance if want to find numbers that are multiples of  2  or multiples of  5 , but not both at the same time we could use the following schema.  {\n  \"oneOf\": [\n    { \"type\": \"integer\", \"multipleOf\": 2 }, \n    { \"type\": \"integer\", \"multipleOf\": 5}\n  ]\n}  This schema validates against  4  and  15 , but it does not validate against  10 , as it satisfies both of the schemas. Equally, the schema does not validate against  3 , or any document that is not an integer.  not  To say that a document does not validate against a certain schema we use the  \"not\"  keyword. For instance the schema below validates against any document that is not a string.  { \"not\": { \"type\": \"string\" } }    It accepts the document  4  or  { \"name\": \"Gary\" } , but not  \"name\" , or any other string.    Formal Specification  Combined restrictions  combRes  are formally specified using the following grammar.   combRes  :=  allOf  |  anyOf |  oneOf  |  not  anyOf  := \"anyOf\": [ {  JSch  } (, {  JSch  })* ] allOf  := \"allOf\": [ {  JSch  } (, {  JSch  })* ] oneOf  := \"oneOf\": [ {  JSch  } (, {  JSch  })* ] not  := \"not\": {  JSch  }  where  JSch  denotes an arbitrary JSON Schema.  Formal Validation  Let  C  be a Combined Restriction and  J  a JSON document. We say that  J  validates against  C  if:   C  is of the form  \"anyOf\": [{Sch 1 }, {Sch 2 }, ... ,{Sch n }]  and  J  conforms to  some   Sch i , for  i = 1 ... n  C  is of the form  \"allOf\": [{Sch 1 }, {Sch 2 }, ... ,{Sch n }]  and  J  conforms to  all  of  Sch i , for  i = 1 ... n  C  is of the form  \"oneOf\": [{Sch 1 }, {Sch 2 }, ... ,{Sch n }]  and  J  conforms to  exactly one  of  Sch i , for  i = 1 ... n  C  is of the form  \"not\": {Sch}  and  J  does  not  validate against  Sch .", 
            "title": "Combined Restrictions"
        }, 
        {
            "location": "/spec/generic_keywords/#enumerated-values", 
            "text": "The  \"enum\"  keyword restricts JSON instances to have certain values specified in an array following the keyword. Let's take a look the following example:  {\n \"type\": \"string\",\n \"enum\": [\"Inter Milan\", \"AC Milan\", \"Juventus\", \"Roma\"]\n}  Here we are asking for JSON strings with the values  \"Inter Milan\" ,  \"AC Milan\" ,  \"Juventus\"  or  \"Roma\" . Apart from these, no other JSON string will be validated against the schema. For example the following JSON instance validates against the schema  \"AC Milan\"  But this one does not  \"Fiorentina\"  The  enum  keyword also allows us have different types in the list of allowed values. Consider the schema:  {\n \"enum\": [\"Two\", 2, true, null]\n}  Then the following JSON validates against the  schema:  null  But this one does not:  16  Formal Specification  The  \"enum\"  restriction is formally specified using the following grammar.   enum  := \"enum\": [ Jval  (,  Jval ) * ]  Where  Jval  can be either a  number , a  string , an  object , an  array , a  boolean  or a  null  value. Note that each  Jval  must be different from the the other values appearing in the array.  Formal Validation  Let  S  be Schema and  J  a JSON document. We say that  J  validates against  S  if the following holds:   S  has the restriction  \"enum\": [val 1  , ... , val n]  and  J  equals  val i  for some  i  in [  1  , ...,  n  ].", 
            "title": "Enumerated Values"
        }, 
        {
            "location": "/spec/generic_keywords/#metadata", 
            "text": "The following group of keywords represent metadata of the schema and does not have a very strong semantic. However, it is a good practice both for programmers and users to provide this information. These keywords can be either  \"title\" ,  \"description\" ,  \"default\"  or  \"$schema\" . Let us take a look to the following example  {\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"Player schema\",\n    \"description\": \"This schema accepts soccer players\",\n    \"default\": null,\n    \"type\": \"object\",\n    \"properties\": {\n        \"first_name\": { \"type\": \"string\" },\n        \"last_name\": { \"type\": \"string\" },\n        \"age\": { \"type\": \"integer\" },\n        \"club\": {\n            \"type\": \"object\",\n            \"properties\": {\n                \"name\": { \"type\": \"string\" },\n                \"founded\": { \"type\": \"integer\" }\n            },\n            \"required\": [\"name\"]\n        }\n    },\n    \"required\": [\"first_name\", \"last_name\", \"age\", \"club\"]\n}  First, the  \"$schema\"  keyword specifies that the current schema follows the specification of the version 3 of JSON Schema. We can provide different versions deppending of our requirements. The  \"title\"  keyword is useful to give a name to the schema. Similarly, the  \"description\"  keyword is useful to give a short description of what kind of documents the schema accepts. Finally the  \"default\"  keyword can be used to specify a default value for the document if a hipothetical validator reads a missing value as input.", 
            "title": "Metadata"
        }, 
        {
            "location": "/spec/multiple_types/", 
            "text": "Multiple Types\n\n\nSo far we have only described how to specify types uniquely. But we could also specify that a certain document may be any number of types, such as string or integer, object or array, etc.\n\n\nThe basic declaration of multiple types is through the \n\"type\"\n keyword, where we can now have an array containing different types. For example, the following schema specifies integers and strings: \n\n\n{\n\u00a0 \u00a0 \"type\": [\"integer\", \"string\"]\n}\n\n\n\nIn addition, we also have the empty schema, that specifies all possible types of JSON documents \n\n\n{}\n\n\n\nHow restrictions work under multiple types\n\n\nThe Keyword restrictions work a little different when multiple (or no) types are defined. Recall how, in the schema: \n\n\n{\n\u00a0 \u00a0 \"type\": \"string\",\n\u00a0 \u00a0 \"minLength\": 4\n}\n\n\n\nthe keyword \n\"minLength\": 4\n imposes the restriction that all documents specified by this schema must have length at least 4 (all documents specified are strings). Likewise, in the schema\n\n\n{\n\u00a0 \u00a0 \"type\": \"integer\",\n\u00a0 \u00a0 \"minimum\": 2\n}\n\n\n\nthe keyword \n\"minimum\": 2\n imposes the restriction that all documents specified by it must be greater than or equal to 2 (all documents specified by the schema are integers).\n\n\nIn schemas that specify either integer or strings these restrictions work in a slightly different way. Restrictions are only checked when the document is of a type that is compatible with the keyword.\n\n\nConsider for example the schema:\n\n\n{\n\u00a0 \u00a0 \"type\": [\"integer\",\"string\"],\n\u00a0 \u00a0 \"minimum\": 2,\n\u00a0 \u00a0 \"minLength\": 4\n}\n\n\n\nThis schema specifies both integers that are greater than or equal than \n2\n and strings that are of length at least \n4\n. In other words, the schema above is equivalent to: \n\n\n{\n    \"anyOf\": [\n\u00a0 \u00a0     {\n\u00a0 \u00a0         \"type\": \"integer\",\n\u00a0 \u00a0         \"minimum\": 2\n\u00a0 \u00a0     }, \n\u00a0 \u00a0     {\n\u00a0 \u00a0         \"type\": \"string\",\n\u00a0 \u00a0         \"minLength\": 4\n\u00a0 \u00a0     }\n\u00a0 \u00a0 ]\n}\n\n\n\nIn general, when multiple (or no) types are defined in the schema, the rule for restrictions is as follows: each keyword restriction only applies when validating documents that are of the type that is compatible with the keyword. \n\n\nAs another example, the following schema specifies JSON documents that are either arrays, strings, integers, numbers, boolean or nulls, and also objects that have the property \n\"I_apply_only_to_objects\"\n: \n\n\n{\n    \"required\": [\"I_apply_only_to_objects\"]\n}\n\n\n\nThis is again equivalent to \n\n\n{\n    \"anyOf\": [\n        {\n        \"not\": {\n        \"type\": \"object\"\n        }\n         }, \n        {\n            \"type\": \"object\",\n            \"required\": [\"I_apply_only_to_objects\"] \n        }\n    ]\n}\n\n\n\nA list of all keywords and the types compatible are given below:\n\n\n\n\n\n\n\n\ntype\n\n\ncompatible keywords\n\n\n\n\n\n\n\n\n\n\nstring\n\n\n\"type\", \"minLength\", \"maxLength\",  \"pattern\".\n\n\n\n\n\n\nnumber\n\n\n\"type\", \"minimum\", \"maximum\", \"exclusiveMinimum\", \"exclusiveMaximum\", \"multipleOf\".\n\n\n\n\n\n\ninteger\n\n\n\"type\", \"minimum\", \"maximum\", \"exclusiveMinimum\", \"exclusiveMaximum\", \"multipleOf\".\n\n\n\n\n\n\nboolean\n\n\n\"type\".\n\n\n\n\n\n\nnull\n\n\n\"type\".\n\n\n\n\n\n\narray\n\n\n\"type\", \"minItems\", \"maxItems\", \"items\", \"uniqueItems\".\n\n\n\n\n\n\nobject\n\n\n\"type\", \"properties\", \"additionalProperties\", \"required\", \"minProperties\", \"maxProperties\", \"dependencies\", \"patternProperties\", \"regexp\".\n\n\n\n\n\n\n\n\nFormal Specification\n\n\nMultiple types are created according to the following grammar (most of the tokens here were defined in previous sections) \n\n\n\n\nmultSch\n :=   \nmultRes\n (, \nmultRes\n)*\n\nmultRes\n := \ntype\n | \nstrRes\n | \nnumRes\n | \narrRes\n | \nobjRes\n\n\ntype\n := \"type\" : [\ntypename\n (, \ntypename\n)*]\n\ntypename\n := \"string\" | \"integer\" | \"number\" | \"boolean\" | \"null\" | \"array\" | \"object\"\n\n\n\n\nWhere as usual each of the words replaced for the  \nmultRes\n tokens is unique. \n\n\nFormal Validation\n\n\nWe define the function \nCompatible(J,k)\n that takes a JSON document \nJ\n and a key/value pair \nk\n of the form \nkey: value\n and returns \ntrue\n if \nkey\n is a string in the following list:\n\n\n\n\n\n\n\n\nlist of keywords\n\n\n\n\n\n\n\n\n\n\n\"type\", \"minLength\", \"maxLength\",  \"pattern\", \"minimum\", \"maximum\", \"exclusiveMinimum\", \"exclusiveMaximum\", \"multipleOf\", \"minItems\", \"maxItems\", \"items\", \"uniqueItems\", \"properties\", \"additionalProperties\", \"required\", \"minProperties\", \"maxProperties\", \"dependencies\", \"patternProperties\", \"regexp\".\n\n\n\n\n\n\n\n\nand \nkey\n is compatible to the type of \nJ\n according to the compatibility table above. Otherwise, \nCompatible(J,k)\n returns \nfalse\n. \n\n\nLet \nM\n be a multiple type Schema and \nJ\n a JSON document. We say that \nJ\n validates against \nM\n if one of the following holds:\n\n\n\n\n\n\nfor each name/value pair \nk\n in \nM\n we have that \nCompatible(J,k) = false\n  \n\n\n\n\n\n\nfor each name/value pair \nk\n in \nM\n such that \nCompatible(J,k) = true\n we have that \nJ\n validates against \nk\n. Here we must note that the semantics of \nk\n is mentioned in each type section\n\n\n\n\n\n\nM\n has the name/value pair \n\"type: [t\n1\n ... t\nn\n]\"\n and for some \nt\ni\n, \nJ\n is of type \nt\ni\n\n\n\n\n\n\nConclusions\n\n\nFinally we must mention that the use of the \ntype\n keyword is a highly recommended practice by the community. As we learnt in this section the multiple type instances can be easily simulated using boolean combinations of schemas and do not seem to expand the expressive power of JSON Schemas.", 
            "title": "Multiple Types"
        }, 
        {
            "location": "/spec/multiple_types/#multiple-types", 
            "text": "So far we have only described how to specify types uniquely. But we could also specify that a certain document may be any number of types, such as string or integer, object or array, etc.  The basic declaration of multiple types is through the  \"type\"  keyword, where we can now have an array containing different types. For example, the following schema specifies integers and strings:   {\n\u00a0 \u00a0 \"type\": [\"integer\", \"string\"]\n}  In addition, we also have the empty schema, that specifies all possible types of JSON documents   {}", 
            "title": "Multiple Types"
        }, 
        {
            "location": "/spec/multiple_types/#how-restrictions-work-under-multiple-types", 
            "text": "The Keyword restrictions work a little different when multiple (or no) types are defined. Recall how, in the schema:   {\n\u00a0 \u00a0 \"type\": \"string\",\n\u00a0 \u00a0 \"minLength\": 4\n}  the keyword  \"minLength\": 4  imposes the restriction that all documents specified by this schema must have length at least 4 (all documents specified are strings). Likewise, in the schema  {\n\u00a0 \u00a0 \"type\": \"integer\",\n\u00a0 \u00a0 \"minimum\": 2\n}  the keyword  \"minimum\": 2  imposes the restriction that all documents specified by it must be greater than or equal to 2 (all documents specified by the schema are integers).  In schemas that specify either integer or strings these restrictions work in a slightly different way. Restrictions are only checked when the document is of a type that is compatible with the keyword.  Consider for example the schema:  {\n\u00a0 \u00a0 \"type\": [\"integer\",\"string\"],\n\u00a0 \u00a0 \"minimum\": 2,\n\u00a0 \u00a0 \"minLength\": 4\n}  This schema specifies both integers that are greater than or equal than  2  and strings that are of length at least  4 . In other words, the schema above is equivalent to:   {\n    \"anyOf\": [\n\u00a0 \u00a0     {\n\u00a0 \u00a0         \"type\": \"integer\",\n\u00a0 \u00a0         \"minimum\": 2\n\u00a0 \u00a0     }, \n\u00a0 \u00a0     {\n\u00a0 \u00a0         \"type\": \"string\",\n\u00a0 \u00a0         \"minLength\": 4\n\u00a0 \u00a0     }\n\u00a0 \u00a0 ]\n}  In general, when multiple (or no) types are defined in the schema, the rule for restrictions is as follows: each keyword restriction only applies when validating documents that are of the type that is compatible with the keyword.   As another example, the following schema specifies JSON documents that are either arrays, strings, integers, numbers, boolean or nulls, and also objects that have the property  \"I_apply_only_to_objects\" :   {\n    \"required\": [\"I_apply_only_to_objects\"]\n}  This is again equivalent to   {\n    \"anyOf\": [\n        {\n        \"not\": {\n        \"type\": \"object\"\n        }\n         }, \n        {\n            \"type\": \"object\",\n            \"required\": [\"I_apply_only_to_objects\"] \n        }\n    ]\n}  A list of all keywords and the types compatible are given below:     type  compatible keywords      string  \"type\", \"minLength\", \"maxLength\",  \"pattern\".    number  \"type\", \"minimum\", \"maximum\", \"exclusiveMinimum\", \"exclusiveMaximum\", \"multipleOf\".    integer  \"type\", \"minimum\", \"maximum\", \"exclusiveMinimum\", \"exclusiveMaximum\", \"multipleOf\".    boolean  \"type\".    null  \"type\".    array  \"type\", \"minItems\", \"maxItems\", \"items\", \"uniqueItems\".    object  \"type\", \"properties\", \"additionalProperties\", \"required\", \"minProperties\", \"maxProperties\", \"dependencies\", \"patternProperties\", \"regexp\".     Formal Specification  Multiple types are created according to the following grammar (most of the tokens here were defined in previous sections)    multSch  :=    multRes  (,  multRes )* multRes  :=  type  |  strRes  |  numRes  |  arrRes  |  objRes  type  := \"type\" : [ typename  (,  typename )*] typename  := \"string\" | \"integer\" | \"number\" | \"boolean\" | \"null\" | \"array\" | \"object\"  Where as usual each of the words replaced for the   multRes  tokens is unique.   Formal Validation  We define the function  Compatible(J,k)  that takes a JSON document  J  and a key/value pair  k  of the form  key: value  and returns  true  if  key  is a string in the following list:     list of keywords      \"type\", \"minLength\", \"maxLength\",  \"pattern\", \"minimum\", \"maximum\", \"exclusiveMinimum\", \"exclusiveMaximum\", \"multipleOf\", \"minItems\", \"maxItems\", \"items\", \"uniqueItems\", \"properties\", \"additionalProperties\", \"required\", \"minProperties\", \"maxProperties\", \"dependencies\", \"patternProperties\", \"regexp\".     and  key  is compatible to the type of  J  according to the compatibility table above. Otherwise,  Compatible(J,k)  returns  false .   Let  M  be a multiple type Schema and  J  a JSON document. We say that  J  validates against  M  if one of the following holds:    for each name/value pair  k  in  M  we have that  Compatible(J,k) = false       for each name/value pair  k  in  M  such that  Compatible(J,k) = true  we have that  J  validates against  k . Here we must note that the semantics of  k  is mentioned in each type section    M  has the name/value pair  \"type: [t 1  ... t n ]\"  and for some  t i ,  J  is of type  t i    Conclusions  Finally we must mention that the use of the  type  keyword is a highly recommended practice by the community. As we learnt in this section the multiple type instances can be easily simulated using boolean combinations of schemas and do not seem to expand the expressive power of JSON Schemas.", 
            "title": "How restrictions work under multiple types"
        }, 
        {
            "location": "/spec/definitions_references/", 
            "text": "Definitions \n References\n\n\nThe JSON Schema specification also allows us to define auxiliary schema in order to be reused and combined later on. \n\n\nThis feature involves two steps: First we need to define the subschemas that shall be used later on, and then we need a standard for calling and reusing these definitions. \n\n\nDefinitions\n\n\nTo establish a difference between the main schema and the auxiliary definitions we adopt the convention that every JSON Schema document consists of two parts. A JSON Schema, and a set of definitions. \n\n\nFor example, suppose we want to define a Schema for documents containing information about names and ages of people. Earlier in this guide we used this schema:\n\n\n{\n    \"type\": \"object\",\n    \"required\": [\"first_name\", \"last_name\", \"age\"],\n    \"properties\": {\n        \"first_name\": {\"type\": \"string\"},\n        \"last_name\": {\"type\": \"string\"},\n        \"age\": {\"type\": \"integer\"}\n    }\n}\n\n\n\nIt specifies objects that must have a \nfirst_name\n, a \nlast_name\n and an \nage\n. Now we want to create a definition, called \nperson\n, that represents this schema. We do it as follows: \n\n\n{\n    \"definitions\": {\n        \"person\": {\n            \"type\": \"object\",\n            \"required\": [\"first_name\", \"last_name\", \"age\"],\n            \"properties\": {\n                \"first_name\": {\"type\": \"string\"},\n                \"last_name\": {\"type\": \"string\"},\n                \"age\": {\"type\": \"integer\"}\n            }\n        }\n    }\n}\n\n\n\nWe could also have several definitions in a document. Here we add \n\"football_team\"\n to \n\"person\"\n:\n\n\n{\n    \"definitions\": {\n        \"person\": {\n            \"type\": \"object\",\n            \"required\": [\"first_name\", \"last_name\", \"age\"],\n            \"properties\": {\n                \"first_name\": {\"type\": \"string\"},\n                \"last_name\": {\"type\": \"string\"},\n                \"age\": {\"type\": \"integer\"}\n            }\n        },\n        \"football_team\": {\n            \"type\": \"object\",\n            \"required\": [\"team\", \"league\"],\n            \"properties\": {\n                \"team\": {\"type\": \"string\"},\n                \"league\": {\"type\": \"string\"},\n                \"year_founded\": {\"type\": \"integer\"}\n            }\n        }\n\n    }\n}\n\n\n\nFormal Specification\n\n\nWe can plug in these definitions at the top level of any JSON Schema. The resulting grammar looks as follows, where \nJSDoc\n is a JSON Document that contains a Schema, \nJSch\n is the primitive used early on in this guide, and \nJSON\n can be any JSON document. \n\n\n\n\nJSDoc\n := { ( \ndefs\n, )? \nJSch\n }\n\ndefs\n := \"definitions\": { \nJSON\n } \n\n\n\n\nOf course, we will see in a minute that \ndefs\n will only be usefull if some parts of \nJSON\n are actually valid JSON Schemas. \n\n\nReferences\n\n\nNow we get to use the schemas we have defined with definitions. Do we need to specify football players? Easy. Just combine a person with a football team: \n\n\n{\n    \"definition\": {\n        \"person\": {\n            \"type\": \"object\",\n            \"required\": [\"first_name\", \"last_name\", \"age\"],\n            \"properties\": {\n                \"first_name\": {\"type\": \"string\"},\n                \"last_name\": {\"type\": \"string\"},\n                \"age\": {\"type\": \"integer\"}\n            }\n        },\n        \"football_team\": {\n            \"type\": \"object\",\n            \"required\": [\"name\", \"league\"],\n            \"properties\": {\n                \"name\": {\"type\": \"string\"},\n                \"league\": {\"type\": \"string\"},\n                \"year_founded\": {\"type\": \"integer\"}\n            }\n        }\n\n    }, \n    \"allOf\": [\n        {\"$ref\": \"#/definitions/person\"},\n        {\"$ref\": \"#/definitions/football_team\"} \n    ]\n}\n\n\n\nNote how this document has two parts. The first part is under the \n\"definitions\"\n keyword, and it simply defines \nperson\n and \nfootball_team\n. The second part is the actual schema. It specifies documents that satisfy both the \nschema under \nperson\n and the schema under \nfootball_team\n. For example, the following object validates against this schema: \n\n\n{\n    \"first_name\": \"Gary\",\n    \"last_name\": \"Medel\",\n    \"age\": 27, \n    \"name\": \"Inter de Milan\", \n    \"league\": \"Serie A\"\n}\n\n\n\nOf course, the reuse of \n\"name\"\n here is a bit confusing. We better place the information about the team as a separate object: \n\n\n{\n    \"definitions\": {\n        \"person\": {\n            \"type\": \"object\",\n            \"required\": [\"first_name\", \"last_name\", \"age\"],\n            \"properties\": {\n                \"first_name\": {\"type\": \"string\"},\n                \"last_name\": {\"type\": \"string\"},\n                \"age\": {\"type\": \"integer\"}\n            }\n        },\n        \"football_team\": {\n            \"type\": \"object\",\n            \"required\": [\"name\", \"league\"],\n            \"properties\": {\n                \"name\": {\"type\": \"string\"},\n                \"league\": {\"type\": \"string\"},\n                \"year_founded\": {\"type\": \"integer\"}\n            }\n        }\n\n    }, \n    \"allOf\": [\n        {\"$ref\": \"#/definitions/person\"},\n        {\n            \"type\": \"object\",\n            \"required\": [\"current_club\"], \n            \"properties\": {\n                \"current_club\": {\"$ref\": \"#/definitions/football_team\"}\n            }\n        } \n    ]\n}\n\n\n\nNow this specifies documents such as the following one:\n\n\n{\n    \"first_name\": \"Gary\",\n    \"last_name\": \"Medel\",\n    \"age\": 27, \n    \"current_club\": {\n        \"name\": \"Inter de Milan\", \n        \"league\": \"Serie A\"\n    }\n}\n\n\n\nMuch better!\n\n\nJSON Pointers\n\n\nBefore we can formally explain how the $ref keyword works we need to talk a bit about JSON pointers. The whole idea of this tool is to use a URI to specify a pointer to a given section of a JSON Document. We just use a fraction of what is defined in the\n\nOfficial Specification\n.\n\n\nFormal Specification\n\n\nFor the purprose of JSON pointer, we can think of a URI as a string of the form \n\n\n\nuri\n = ( \naddress\n )? ( # / \nJPointer\n )?\n\n\n\nSimply said, \naddress\n corresponds to any URI that does not use the \n#\n symbol, or more precisely to any URI-reference constructed using the following grammar, as defined in the \nofficial standard\n:\n\n\n\naddress\n = (\nscheme\n : )? \nhier-part\n (? \nquery\n ) \n\n\n\nJSON pointers are specified as follows: \n\n\n\nJPointer\n := ( / \npath\n )\n\n\npath\n := ( \nunescaped\n | \nescaped\n )\n\n\nescaped\n := ~0 | ~1\n\n\n\nWhere \nunescaped\n can be any character except for \n/\n and \n~\n. To represent these characters we use the \nescaped\n \n~0\n for \n~\nand \n~1\n for \n/\n. \n\n\nFor example, \n/definitions/person\n is a JSON Pointer, and so is \n/pointer/0/with/numbers/12\n and \npointer/with/~1escaped/~0chars\n. Note how the last is actually a representation of the string \npointer/with//escaped/~chars\n.\n\n\nIf \npath\n is a string of the form above, we say that \nrep(path)\n is the string resulting of replacing first each character \n~1\n by \n/\n and then each character \n~0\n by \n~\n.\n\n\nJson Pointer Evaluation\n\n\nLet \nJ\n be a JSON document. JSON Pointers are intended to extract a part of \nJ\n that is specifically indexed by the pointer. Formally, we define the function \nEVAL()\n that takes a JSON Document and a JSON Pointer and delivers a subset of \nJ\n. \n\n\nGiven a JSON document \nJ\n that is an object, we use \nJ[k]\n (for a string \nk\n) to represent the value of the key value pair in \nJ\n whose key is \nk\n. Likewise, if \nJ\n is an array, then \nJ[n]\n (for a natural number \nn\n) corresponds to the \nn\n-th element of \nJ\n. \nWe also say that a keyword \nk\n appears in \nJ\n if \nJ\n contains a key:value pair of the form \nk: j'\n, for some document \nj'\n. \n\n\n\n\nEVAL(J,JPointer)\n returns: \n\n\n\n\n\n\nJ\n, if \nJPointer\n is the empty string\n, or \n\n\n\n\n\n\nEVAL(J[rep(key)],JP)\n, if \nJ\n is an object, \nrep(key)\n appears in \nJ\n and \nJPointer\n is of the form \nJP/key\n, or\n\n\n\n\nEVAL(J[n],JP)\n, if \nJPointer\n is an array with at least \nn+1\n objects and \nJPointer\n is of the form \nJP/n\n, where \nn\n is the base-10 representation of a natural number, or\n\n\nan error in any other case (for example when the pointer asks for a key that is not in \nJ\n). \n\n\n\n\nReference Specification\n\n\nThe idea of a reference such as \n{\"$ref\": \"#/definitions/person\"}\n is to use the schema that is stored under the result of evaluating the pointer \n/definitions/person\n under the same document that is defining the JSON Schema. \n\n\nWe could also be looking elsewhere for references. In order to do this we need to add the \naddress\n part of the URI in the reference keyword. \n\n\nFor example, assume that the URI \nhttp://db.ing.puc.cl/exampleschema\n retrieves the following json document: \n\n\n{\n    \"definitions\": {\n        \"person\": {\n            \"type\": \"object\",\n            \"required\": [\"first_name\", \"last_name\", \"age\"],\n            \"properties\": {\n                \"first_name\": {\"type\": \"string\"},\n                \"last_name\": {\"type\": \"string\"},\n                \"age\": {\"type\": \"integer\"}\n            }\n        },\n    },\n    \"type\": \"object\",\n    \"required\": [\"name\", \"league\"],\n    \"properties\": {\n        \"name\": {\"type\": \"string\"},\n        \"league\": {\"type\": \"string\"},\n        \"year_founded\": {\"type\": \"integer\"}\n    }\n}\n\n\n\nWe can mix URIs and JSON Pointers: the reference \nhttp://db.ing.puc.cl/exampleschema\n retrieves this entire schema, but the reference \nhttp://db.ing.puc.cl/exampleschema#/definitions/person\n retrieves only \n\n\n{\n    \"type\": \"object\",\n    \"required\": [\"first_name\", \"last_name\", \"age\"],\n    \"properties\": {\n        \"first_name\": {\"type\": \"string\"},\n        \"last_name\": {\"type\": \"string\"},\n        \"age\": {\"type\": \"integer\"}\n    }\n}\n\n\n\nNow if we want to specify again the schema for football players, we can do it as follows: \n\n\n{\n    \"allOf\": [\n        {\"$ref\": \"http://db.ing.puc.cl/exampleschema#/definitions/person\"},\n        {\n            \"type\": \"object\",\n            \"required\": [\"current_club\"], \n            \"properties\": {\n            \"current_club\": {\"$ref\": \"http://db.ing.puc.cl/exampleschema\"}\n            }\n        } \n    ]\n}\n\n\n\nAs mentioned, \nhttp://db.ing.puc.cl/exampleschema#/definitions/person\n retrieves only the schema for persons, while \n{\"$ref\": \"http://db.ing.puc.cl/exampleschema\"}\n retrieves the entire document (naturally, for validation purproses we are only interested in the schema, not in the definitions portion). \n\n\nFormal Specification\n\n\nNote that \nuriRef\n below is the same grammar we defined earlier for URIs. \n\n\n\nrefSch\n := \"$ref\": \" \nuriRef\n \" \n\nuriRef\n := ( \naddress\n )? ( # / \nJPointer\n )?\n\n\n\nFormal Validation\n\n\nLet \nR\n be a JSON Reference of the form \n\"$ref\": uriRef\n. We extend the function \nEVAL()\n to work with arbitrary JSON references. We do it as follows. \n\n\nEVAL(J,R)\n returns: \n\n\n\n\n\n\nEVAL(J,JPointer)\n, if \nuriRef\n is of the form \n#/JPointer\n, or \n\n\n\n\n\n\nS\n, if \nuriRef\n does not contains the symbol \n#\n and the address in \nuriRef\nsuccesfully retrieves the schema \nS\n, or \n\n\n\n\n\n\nEVAL(S,JPointer)\n, if \nuriRef\n is of the form \naddress#/JPointer\n and the address in \nuriRef\nsuccesfully retrieves the schema \nS\n, or \n\n\n\n\n\n\nan error in any other case (for example when the address retrieves something that is not a schema). \n\n\n\n\n\n\nLet \nR\n be again a JSON Reference and \nJ\n a JSON document. Assume that the JSON schema document that contains \nR\n is \nS\n. Then we say that \nJ\n validates against \nR\n under \nS\n if \nEVAL(S,R)\n returns a schema (not an error) and \nJ\n validates against \nEVAL(S,R)\n.\n\n\nID\n\n\nThe JSON Schema specification also includes the option of an \nid\n keyword. This keywords has many uses, here we only comment on the most simple of all: setting up a unique identifier for the schema. \n\n\nAs an example, look at the use of the \nid\n keyword in the following schema: \n\n\n{\n    \"id\": \"http://db.ing.puc.cl/exampleschema\", \n    \"definitions\": {\n        \"person\": {\n            \"type\": \"object\",\n            \"required\": [\"first_name\", \"last_name\", \"age\"],\n            \"properties\": {\n                \"first_name\": {\"type\": \"string\"},\n                \"last_name\": {\"type\": \"string\"},\n                \"age\": {\"type\": \"integer\"}\n            }\n        }\n    },\n    \"type\": \"object\",\n    \"required\": [\"name\", \"league\"],\n    \"properties\": {\n        \"name\": {\"type\": \"string\"},\n        \"league\": {\"type\": \"string\"},\n        \"year_founded\": {\"type\": \"integer\"}\n    }\n}\n\n\n\nThis sets up \"http://db.ing.puc.cl/exampleschema\" as the identifier for the schema. Some validators may choose to retrieve the above schema instead of looking for the schema that the url http://db.ing.puc.cl/exampleschema is pointing at when faced with the keyword \n{\"$ref\": \"http://db.ing.puc.cl/exampleschema\"}\n, but this is only optional, and therefore the only \nsafe\n use of the id keyword is when the id of the schema coincides with the document that the id points at.", 
            "title": "Definitions & References"
        }, 
        {
            "location": "/spec/definitions_references/#definitions-references", 
            "text": "The JSON Schema specification also allows us to define auxiliary schema in order to be reused and combined later on.   This feature involves two steps: First we need to define the subschemas that shall be used later on, and then we need a standard for calling and reusing these definitions.", 
            "title": "Definitions &amp; References"
        }, 
        {
            "location": "/spec/definitions_references/#definitions", 
            "text": "To establish a difference between the main schema and the auxiliary definitions we adopt the convention that every JSON Schema document consists of two parts. A JSON Schema, and a set of definitions.   For example, suppose we want to define a Schema for documents containing information about names and ages of people. Earlier in this guide we used this schema:  {\n    \"type\": \"object\",\n    \"required\": [\"first_name\", \"last_name\", \"age\"],\n    \"properties\": {\n        \"first_name\": {\"type\": \"string\"},\n        \"last_name\": {\"type\": \"string\"},\n        \"age\": {\"type\": \"integer\"}\n    }\n}  It specifies objects that must have a  first_name , a  last_name  and an  age . Now we want to create a definition, called  person , that represents this schema. We do it as follows:   {\n    \"definitions\": {\n        \"person\": {\n            \"type\": \"object\",\n            \"required\": [\"first_name\", \"last_name\", \"age\"],\n            \"properties\": {\n                \"first_name\": {\"type\": \"string\"},\n                \"last_name\": {\"type\": \"string\"},\n                \"age\": {\"type\": \"integer\"}\n            }\n        }\n    }\n}  We could also have several definitions in a document. Here we add  \"football_team\"  to  \"person\" :  {\n    \"definitions\": {\n        \"person\": {\n            \"type\": \"object\",\n            \"required\": [\"first_name\", \"last_name\", \"age\"],\n            \"properties\": {\n                \"first_name\": {\"type\": \"string\"},\n                \"last_name\": {\"type\": \"string\"},\n                \"age\": {\"type\": \"integer\"}\n            }\n        },\n        \"football_team\": {\n            \"type\": \"object\",\n            \"required\": [\"team\", \"league\"],\n            \"properties\": {\n                \"team\": {\"type\": \"string\"},\n                \"league\": {\"type\": \"string\"},\n                \"year_founded\": {\"type\": \"integer\"}\n            }\n        }\n\n    }\n}  Formal Specification  We can plug in these definitions at the top level of any JSON Schema. The resulting grammar looks as follows, where  JSDoc  is a JSON Document that contains a Schema,  JSch  is the primitive used early on in this guide, and  JSON  can be any JSON document.    JSDoc  := { (  defs , )?  JSch  } defs  := \"definitions\": {  JSON  }   Of course, we will see in a minute that  defs  will only be usefull if some parts of  JSON  are actually valid JSON Schemas.", 
            "title": "Definitions"
        }, 
        {
            "location": "/spec/definitions_references/#references", 
            "text": "Now we get to use the schemas we have defined with definitions. Do we need to specify football players? Easy. Just combine a person with a football team:   {\n    \"definition\": {\n        \"person\": {\n            \"type\": \"object\",\n            \"required\": [\"first_name\", \"last_name\", \"age\"],\n            \"properties\": {\n                \"first_name\": {\"type\": \"string\"},\n                \"last_name\": {\"type\": \"string\"},\n                \"age\": {\"type\": \"integer\"}\n            }\n        },\n        \"football_team\": {\n            \"type\": \"object\",\n            \"required\": [\"name\", \"league\"],\n            \"properties\": {\n                \"name\": {\"type\": \"string\"},\n                \"league\": {\"type\": \"string\"},\n                \"year_founded\": {\"type\": \"integer\"}\n            }\n        }\n\n    }, \n    \"allOf\": [\n        {\"$ref\": \"#/definitions/person\"},\n        {\"$ref\": \"#/definitions/football_team\"} \n    ]\n}  Note how this document has two parts. The first part is under the  \"definitions\"  keyword, and it simply defines  person  and  football_team . The second part is the actual schema. It specifies documents that satisfy both the \nschema under  person  and the schema under  football_team . For example, the following object validates against this schema:   {\n    \"first_name\": \"Gary\",\n    \"last_name\": \"Medel\",\n    \"age\": 27, \n    \"name\": \"Inter de Milan\", \n    \"league\": \"Serie A\"\n}  Of course, the reuse of  \"name\"  here is a bit confusing. We better place the information about the team as a separate object:   {\n    \"definitions\": {\n        \"person\": {\n            \"type\": \"object\",\n            \"required\": [\"first_name\", \"last_name\", \"age\"],\n            \"properties\": {\n                \"first_name\": {\"type\": \"string\"},\n                \"last_name\": {\"type\": \"string\"},\n                \"age\": {\"type\": \"integer\"}\n            }\n        },\n        \"football_team\": {\n            \"type\": \"object\",\n            \"required\": [\"name\", \"league\"],\n            \"properties\": {\n                \"name\": {\"type\": \"string\"},\n                \"league\": {\"type\": \"string\"},\n                \"year_founded\": {\"type\": \"integer\"}\n            }\n        }\n\n    }, \n    \"allOf\": [\n        {\"$ref\": \"#/definitions/person\"},\n        {\n            \"type\": \"object\",\n            \"required\": [\"current_club\"], \n            \"properties\": {\n                \"current_club\": {\"$ref\": \"#/definitions/football_team\"}\n            }\n        } \n    ]\n}  Now this specifies documents such as the following one:  {\n    \"first_name\": \"Gary\",\n    \"last_name\": \"Medel\",\n    \"age\": 27, \n    \"current_club\": {\n        \"name\": \"Inter de Milan\", \n        \"league\": \"Serie A\"\n    }\n}  Much better!", 
            "title": "References"
        }, 
        {
            "location": "/spec/definitions_references/#json-pointers", 
            "text": "Before we can formally explain how the $ref keyword works we need to talk a bit about JSON pointers. The whole idea of this tool is to use a URI to specify a pointer to a given section of a JSON Document. We just use a fraction of what is defined in the Official Specification .  Formal Specification  For the purprose of JSON pointer, we can think of a URI as a string of the form   uri  = (  address  )? ( # /  JPointer  )?  Simply said,  address  corresponds to any URI that does not use the  #  symbol, or more precisely to any URI-reference constructed using the following grammar, as defined in the  official standard :  address  = ( scheme  : )?  hier-part  (?  query  )   JSON pointers are specified as follows:   JPointer  := ( /  path  )  path  := (  unescaped  |  escaped  )  escaped  := ~0 | ~1  Where  unescaped  can be any character except for  /  and  ~ . To represent these characters we use the  escaped   ~0  for  ~ and  ~1  for  / .   For example,  /definitions/person  is a JSON Pointer, and so is  /pointer/0/with/numbers/12  and  pointer/with/~1escaped/~0chars . Note how the last is actually a representation of the string  pointer/with//escaped/~chars .  If  path  is a string of the form above, we say that  rep(path)  is the string resulting of replacing first each character  ~1  by  /  and then each character  ~0  by  ~ .  Json Pointer Evaluation  Let  J  be a JSON document. JSON Pointers are intended to extract a part of  J  that is specifically indexed by the pointer. Formally, we define the function  EVAL()  that takes a JSON Document and a JSON Pointer and delivers a subset of  J .   Given a JSON document  J  that is an object, we use  J[k]  (for a string  k ) to represent the value of the key value pair in  J  whose key is  k . Likewise, if  J  is an array, then  J[n]  (for a natural number  n ) corresponds to the  n -th element of  J . \nWe also say that a keyword  k  appears in  J  if  J  contains a key:value pair of the form  k: j' , for some document  j' .    EVAL(J,JPointer)  returns:     J , if  JPointer  is the empty string , or     EVAL(J[rep(key)],JP) , if  J  is an object,  rep(key)  appears in  J  and  JPointer  is of the form  JP/key , or   EVAL(J[n],JP) , if  JPointer  is an array with at least  n+1  objects and  JPointer  is of the form  JP/n , where  n  is the base-10 representation of a natural number, or  an error in any other case (for example when the pointer asks for a key that is not in  J ).", 
            "title": "JSON Pointers"
        }, 
        {
            "location": "/spec/definitions_references/#reference-specification", 
            "text": "The idea of a reference such as  {\"$ref\": \"#/definitions/person\"}  is to use the schema that is stored under the result of evaluating the pointer  /definitions/person  under the same document that is defining the JSON Schema.   We could also be looking elsewhere for references. In order to do this we need to add the  address  part of the URI in the reference keyword.   For example, assume that the URI  http://db.ing.puc.cl/exampleschema  retrieves the following json document:   {\n    \"definitions\": {\n        \"person\": {\n            \"type\": \"object\",\n            \"required\": [\"first_name\", \"last_name\", \"age\"],\n            \"properties\": {\n                \"first_name\": {\"type\": \"string\"},\n                \"last_name\": {\"type\": \"string\"},\n                \"age\": {\"type\": \"integer\"}\n            }\n        },\n    },\n    \"type\": \"object\",\n    \"required\": [\"name\", \"league\"],\n    \"properties\": {\n        \"name\": {\"type\": \"string\"},\n        \"league\": {\"type\": \"string\"},\n        \"year_founded\": {\"type\": \"integer\"}\n    }\n}  We can mix URIs and JSON Pointers: the reference  http://db.ing.puc.cl/exampleschema  retrieves this entire schema, but the reference  http://db.ing.puc.cl/exampleschema#/definitions/person  retrieves only   {\n    \"type\": \"object\",\n    \"required\": [\"first_name\", \"last_name\", \"age\"],\n    \"properties\": {\n        \"first_name\": {\"type\": \"string\"},\n        \"last_name\": {\"type\": \"string\"},\n        \"age\": {\"type\": \"integer\"}\n    }\n}  Now if we want to specify again the schema for football players, we can do it as follows:   {\n    \"allOf\": [\n        {\"$ref\": \"http://db.ing.puc.cl/exampleschema#/definitions/person\"},\n        {\n            \"type\": \"object\",\n            \"required\": [\"current_club\"], \n            \"properties\": {\n            \"current_club\": {\"$ref\": \"http://db.ing.puc.cl/exampleschema\"}\n            }\n        } \n    ]\n}  As mentioned,  http://db.ing.puc.cl/exampleschema#/definitions/person  retrieves only the schema for persons, while  {\"$ref\": \"http://db.ing.puc.cl/exampleschema\"}  retrieves the entire document (naturally, for validation purproses we are only interested in the schema, not in the definitions portion).   Formal Specification  Note that  uriRef  below is the same grammar we defined earlier for URIs.   refSch  := \"$ref\": \"  uriRef  \"  uriRef  := (  address  )? ( # /  JPointer  )?  Formal Validation  Let  R  be a JSON Reference of the form  \"$ref\": uriRef . We extend the function  EVAL()  to work with arbitrary JSON references. We do it as follows.   EVAL(J,R)  returns:     EVAL(J,JPointer) , if  uriRef  is of the form  #/JPointer , or     S , if  uriRef  does not contains the symbol  #  and the address in  uriRef succesfully retrieves the schema  S , or     EVAL(S,JPointer) , if  uriRef  is of the form  address#/JPointer  and the address in  uriRef succesfully retrieves the schema  S , or     an error in any other case (for example when the address retrieves something that is not a schema).     Let  R  be again a JSON Reference and  J  a JSON document. Assume that the JSON schema document that contains  R  is  S . Then we say that  J  validates against  R  under  S  if  EVAL(S,R)  returns a schema (not an error) and  J  validates against  EVAL(S,R) .", 
            "title": "Reference Specification"
        }, 
        {
            "location": "/spec/definitions_references/#id", 
            "text": "The JSON Schema specification also includes the option of an  id  keyword. This keywords has many uses, here we only comment on the most simple of all: setting up a unique identifier for the schema.   As an example, look at the use of the  id  keyword in the following schema:   {\n    \"id\": \"http://db.ing.puc.cl/exampleschema\", \n    \"definitions\": {\n        \"person\": {\n            \"type\": \"object\",\n            \"required\": [\"first_name\", \"last_name\", \"age\"],\n            \"properties\": {\n                \"first_name\": {\"type\": \"string\"},\n                \"last_name\": {\"type\": \"string\"},\n                \"age\": {\"type\": \"integer\"}\n            }\n        }\n    },\n    \"type\": \"object\",\n    \"required\": [\"name\", \"league\"],\n    \"properties\": {\n        \"name\": {\"type\": \"string\"},\n        \"league\": {\"type\": \"string\"},\n        \"year_founded\": {\"type\": \"integer\"}\n    }\n}  This sets up \"http://db.ing.puc.cl/exampleschema\" as the identifier for the schema. Some validators may choose to retrieve the above schema instead of looking for the schema that the url http://db.ing.puc.cl/exampleschema is pointing at when faced with the keyword  {\"$ref\": \"http://db.ing.puc.cl/exampleschema\"} , but this is only optional, and therefore the only  safe  use of the id keyword is when the id of the schema coincides with the document that the id points at.", 
            "title": "ID"
        }, 
        {
            "location": "/spec/why/", 
            "text": "Why a formal specification?\n\n\nThis section is intended to provide a rigorous mathematical definition of how one can construct any JSON Schema starting from a predefined set of primitives (a formal grammar), and how can such a schema be validated against arbitrary JSON documents. But before we give a formal mathematical specification we will briefly explain what advantages does having a fixed grammar for JSON Schema offer.\n\n\nA grammar for JSON Schema is very similar to a grammar of some language (e.g. English, Spanish, French, etc.), since it tells us which Schemas (or sentences in the case of a spoken language) are permitted and which are not permitted. Formal grammars are generally used when we want a clean and easy to process specification of some object or a process, and are used to e.g. specify programming languages, inputs to compilers, in text processing and many other areas.\n\n\nBelow we provide an (incomplete) list of some of the advantages of having a formal grammar for JSON Schema:\n\n\n\n\nFormal grammar will allow us to have an operative definition of when some document is a valid JSON Schema, and when it is not.\n\n\nOnce we give the semantics to basic elements of the grammar, and define what is the meaning of combining them, this will allow us to answer unambiguously the question of when a document satisfies a schema and when it does not.\n\n\nA grammar allows us to check both if the Schema is properly formed, and if a document satisfies the schema, in an automated manner, thus allowing for an easy implementation of validators conforming to this specification.\n\n\nHaving a formal grammar allows us to easily specify the metaschema of JSON Schema (that is, a  schema for JSON Schema), even if one does not know how JSON Schema operates.\n\n\n\n\nWhat happens when there is no formal grammar?\n\n\nTo illustrate what sort of issues one faces when there is no formal and completely unambiguous specification of JSON Schema we designed several tests for checking the properties which were not fully defined in the latest \nJSON Schema draft\n. These test are then passed onto five existing implementations of the latest JSON Schema draft. As we will see, the main problem is that when checked against the same schemas and the same documents, the validators return different results, which is certainly not the outcome one desires. Note that these test do not reflect on the quality of these validators, they simply illustrate what happens when the specification allows a lot of freedom in interpreting how certain aspects of the schema should work. Below we explain the different tests and list the validators that were used, together with the validation results.\n\n\nThe tests\n\n\nHere we describe the schemas and documents used in each test, as well as provide some intuition on which aspects of the JSON Schema specification are they intended to examine.\n\n\nT1\n\n\nThe first test, denoted T1, checks if the validator considers JSON documents to be ordered or not (although this does not refer to the schema specification, it still illustrates that all elements participating in the validation process should be formally specified).\n\n\n{\n\"type\": \"array\",\n \"uniqueItems\": true\n }\n\n\n\nThe document we will be validating against this schema is intended to check if the order of keys in two (syntactically) identical JSON documents matters, and it is given below:\n\n\n[ {\"a\": 3, \"b\": 4}, {\"b\": 4, \"a\": 3} ]\n\n\n\n\nT2\n\n\nThe second test, T2, is intended to check how validators handle the keyword \n\"$ref\"\n, which is intended to overwrite any other alternative specification at the same level (see \nhere\n for more details).\n\n\n{\n \"definitions\": {\n    \"a\": {\"type\": \"string\"}\n   },\n \"$ref\": \"#/definitions/a\",\n \"type\": \"integer\"\n}\n\n\n\n\nThe document in T2 is simply the string \n\"hola\"\n.\n\n\nT3\n\n\nIn T3 we use a schema which requires two properties \n\"a\"\n and \n\"b\"\n to be present, but also specifies that the document is a number which is a multiple of 3. This schema is intended to test how the validator handles enforcing types.\n\n\n{\n \"type\": \"object\",\n \"required\": [\"a\", \"b\"],\n \"multipleOf\": 3\n}\n\n\n\n\nThe document is simply the number \n4\n.\n\n\nT4\n\n\nOur final test (T4) uses a schema containing a cyclical reference (which is allowed in the current draft of JSON Schema). \n\n\n{\n \"definitions\": {\n      \"a\": {\"$ref\": \"#/definitions/a\"}\n     },\n  \"anyOf\": [\n          {\"$ref\": \"#/definitions/a\"},\n          {\"type\": \"string\"}\n         ]\n}\n\n\n\n\nThe document is simply the string \n\"hola\"\n.\n\n\nThe validators used\n\n\nThe validators were downloaded from their respective github repositories, or dedicated Web pages. For those also having an online version we list the corresponding links.\n\n\nV1: \nRuby JSON Schema Validator\n\n\nV2: \nJSON Schema for Python\n\n\nV3: \nJSON Schema validator in Java\n (also available \nonline\n)\n\n\nV4: \nA  JavaScript validator for JSON Schema\n\n\nV5: \nAn old version of the Python validator\n\n\nWe would like to remark that all of these validators claim to pass the \nJSON Schema test suite\n.\n\n\nResults and discussion\n\n\nThe results are summarised in the table below. Here Y stands for accepting the document corresponding to the test, N that the document does not validate, and '--' that the validator does not support this type of schema.\n\n\n\n\n\n\n\n\n\n\n\n\nV1\n\n\nV2\n\n\nV3\n\n\nV4\n\n\nV5\n\n\n\n\n\n\n\n\n\n\nT1\n\n\nN\n\n\nY\n\n\nY\n\n\nN\n\n\nY\n\n\n\n\n\n\nT2\n\n\nY\n\n\nN\n\n\nY\n\n\nN\n\n\nY\n\n\n\n\n\n\nT3\n\n\nN\n\n\nY\n\n\nN\n\n\nN\n\n\nN\n\n\n\n\n\n\nT4\n\n\n--\n\n\n--\n\n\nN\n\n\n--\n\n\n--\n\n\n\n\n\n\n\n\n\n\nAs we can see, different validators implement different features of the \nJSON Schema specification draft\n in a different way, which is certainly not the way we want them to behave, since using a different validator might result in accepting a different class of documents.\n\n\nTo start of, as T1 demonstrates, the validators do not even agree on what is the proper definition of a JSON document. In particular, it seems that some of them consider the documents to be ordered, while the others do not.\n\n\nNext, T2 shows that how the validators treat the \n$ref\n keyword is also not uniform. In particular, some of them do give it a priority over other schemas at the same level, but some do not.\n\n\nAs far as T3 is concerned, it seems that most validators do enforce the type of the JSON document correctly, although even here there are some exceptions.\n\n\nFinally, using cyclic references, although permitted by the \nJSON Schema draft\n, is not supported by most validators, and in the one case that it was supported, the returned result was not correct. On the other hand, it is also debatable how such a property should be implemented, since it could lead to potentially infinite validation sequences.\n\n\nTherefore, the lack of a strict formalisation leaves us with different implementations which can disagree in certain cases. This could potentially result in certain problems, for instance in a scenario where the developers who use different validators wish to exchange their JSON documents and except them to satisfy a certain agreed-upon schema, since the results they get might be different. In order to avoid such scenarios in the rest of this section we provide a formal grammar for JSON Schema and define its semantics in an unambiguous way. In particular, we make sure that JSON files are interpreted correctly (T1), that references and types are enforced as intended (T2 and T3), and that cyclic references which can lead to infinite validation (T4) are not permitted.", 
            "title": "Why a formal specification?"
        }, 
        {
            "location": "/spec/why/#why-a-formal-specification", 
            "text": "This section is intended to provide a rigorous mathematical definition of how one can construct any JSON Schema starting from a predefined set of primitives (a formal grammar), and how can such a schema be validated against arbitrary JSON documents. But before we give a formal mathematical specification we will briefly explain what advantages does having a fixed grammar for JSON Schema offer.  A grammar for JSON Schema is very similar to a grammar of some language (e.g. English, Spanish, French, etc.), since it tells us which Schemas (or sentences in the case of a spoken language) are permitted and which are not permitted. Formal grammars are generally used when we want a clean and easy to process specification of some object or a process, and are used to e.g. specify programming languages, inputs to compilers, in text processing and many other areas.  Below we provide an (incomplete) list of some of the advantages of having a formal grammar for JSON Schema:   Formal grammar will allow us to have an operative definition of when some document is a valid JSON Schema, and when it is not.  Once we give the semantics to basic elements of the grammar, and define what is the meaning of combining them, this will allow us to answer unambiguously the question of when a document satisfies a schema and when it does not.  A grammar allows us to check both if the Schema is properly formed, and if a document satisfies the schema, in an automated manner, thus allowing for an easy implementation of validators conforming to this specification.  Having a formal grammar allows us to easily specify the metaschema of JSON Schema (that is, a  schema for JSON Schema), even if one does not know how JSON Schema operates.   What happens when there is no formal grammar?  To illustrate what sort of issues one faces when there is no formal and completely unambiguous specification of JSON Schema we designed several tests for checking the properties which were not fully defined in the latest  JSON Schema draft . These test are then passed onto five existing implementations of the latest JSON Schema draft. As we will see, the main problem is that when checked against the same schemas and the same documents, the validators return different results, which is certainly not the outcome one desires. Note that these test do not reflect on the quality of these validators, they simply illustrate what happens when the specification allows a lot of freedom in interpreting how certain aspects of the schema should work. Below we explain the different tests and list the validators that were used, together with the validation results.  The tests  Here we describe the schemas and documents used in each test, as well as provide some intuition on which aspects of the JSON Schema specification are they intended to examine.  T1  The first test, denoted T1, checks if the validator considers JSON documents to be ordered or not (although this does not refer to the schema specification, it still illustrates that all elements participating in the validation process should be formally specified).  {\n\"type\": \"array\",\n \"uniqueItems\": true\n }  The document we will be validating against this schema is intended to check if the order of keys in two (syntactically) identical JSON documents matters, and it is given below:  [ {\"a\": 3, \"b\": 4}, {\"b\": 4, \"a\": 3} ]  T2  The second test, T2, is intended to check how validators handle the keyword  \"$ref\" , which is intended to overwrite any other alternative specification at the same level (see  here  for more details).  {\n \"definitions\": {\n    \"a\": {\"type\": \"string\"}\n   },\n \"$ref\": \"#/definitions/a\",\n \"type\": \"integer\"\n}  The document in T2 is simply the string  \"hola\" .  T3  In T3 we use a schema which requires two properties  \"a\"  and  \"b\"  to be present, but also specifies that the document is a number which is a multiple of 3. This schema is intended to test how the validator handles enforcing types.  {\n \"type\": \"object\",\n \"required\": [\"a\", \"b\"],\n \"multipleOf\": 3\n}  The document is simply the number  4 .  T4  Our final test (T4) uses a schema containing a cyclical reference (which is allowed in the current draft of JSON Schema).   {\n \"definitions\": {\n      \"a\": {\"$ref\": \"#/definitions/a\"}\n     },\n  \"anyOf\": [\n          {\"$ref\": \"#/definitions/a\"},\n          {\"type\": \"string\"}\n         ]\n}  The document is simply the string  \"hola\" .  The validators used  The validators were downloaded from their respective github repositories, or dedicated Web pages. For those also having an online version we list the corresponding links.  V1:  Ruby JSON Schema Validator  V2:  JSON Schema for Python  V3:  JSON Schema validator in Java  (also available  online )  V4:  A  JavaScript validator for JSON Schema  V5:  An old version of the Python validator  We would like to remark that all of these validators claim to pass the  JSON Schema test suite .  Results and discussion  The results are summarised in the table below. Here Y stands for accepting the document corresponding to the test, N that the document does not validate, and '--' that the validator does not support this type of schema.       V1  V2  V3  V4  V5      T1  N  Y  Y  N  Y    T2  Y  N  Y  N  Y    T3  N  Y  N  N  N    T4  --  --  N  --  --      As we can see, different validators implement different features of the  JSON Schema specification draft  in a different way, which is certainly not the way we want them to behave, since using a different validator might result in accepting a different class of documents.  To start of, as T1 demonstrates, the validators do not even agree on what is the proper definition of a JSON document. In particular, it seems that some of them consider the documents to be ordered, while the others do not.  Next, T2 shows that how the validators treat the  $ref  keyword is also not uniform. In particular, some of them do give it a priority over other schemas at the same level, but some do not.  As far as T3 is concerned, it seems that most validators do enforce the type of the JSON document correctly, although even here there are some exceptions.  Finally, using cyclic references, although permitted by the  JSON Schema draft , is not supported by most validators, and in the one case that it was supported, the returned result was not correct. On the other hand, it is also debatable how such a property should be implemented, since it could lead to potentially infinite validation sequences.  Therefore, the lack of a strict formalisation leaves us with different implementations which can disagree in certain cases. This could potentially result in certain problems, for instance in a scenario where the developers who use different validators wish to exchange their JSON documents and except them to satisfy a certain agreed-upon schema, since the results they get might be different. In order to avoid such scenarios in the rest of this section we provide a formal grammar for JSON Schema and define its semantics in an unambiguous way. In particular, we make sure that JSON files are interpreted correctly (T1), that references and types are enforced as intended (T2 and T3), and that cyclic references which can lead to infinite validation (T4) are not permitted.", 
            "title": "Why a formal specification?"
        }, 
        {
            "location": "/spec/grammar/", 
            "text": "Syntax\n\n\nA more formal description of how JSON Schemas are built\n\n\nIn this section we define how every JSON Document can be built using a formal grammar. The purpose of this is to have a rigurous specification for JSON documents and to enable the community to solve ambiguities about each operator and type.\n\n\nNotation\n\n\nThe Formal Grammar in this specification is given using a simple, visual-based Extended Backus-Naur Form (EBNF) notation, that we define below. \n\n\nEach rule in the grammar defines one symbol, in the form\n\n\n\n\nsymbol\n := expression\n\n\n\n\nFor readability we always write non-terminal symbols in blackened font, such as \nJSch\n or \nstrRes\n. The expression on the right hand side of these rules may match more than one string, and is constructed according to the following operators: \n\n\n\n\nstring\n any non-blackened string that does not use  \n)\n, \n(\n,  \n|\n or \n?\n matches precisely against the string. \n\n\n\n\nWe also use brackets, as in \n(expression)\n, to specify that the expression inside them is a unit. We can combine units using the following operators\n\n\n\n\nE?\n: optional \nE\n, mathces \nE\n or nothing\n\n\nA | B\n: \nA\n or \nB\n, matches either \nA\n or \nB\n\n\nA B\n \nA\n concatenated with \nB\n, matches \nA\n followed by \nB\n. This operator has higher precedence over \n|\n \n\n\nE*\n: Matches zero or more ocurrences of \nE\n. Also has a higher precedence over \n|\n\n\n\n\nGrammar\n\n\nFormally we define a JSON Schema Document as a set of definitions and a JSON Schema. Each JSON Schema is threated as a set of restrictions that may apply to one or more types. To keep a clean and tidy grammar we divide each restriction in different sections, but as every grammar, the document is defined by the union of all these nested variables.\n\n\nJson Documents and Schemas\n\n\nLet \nJDOC\n be an arbitrary JSON Schema Document. We can define its syntax using the following grammar:\n \n\n\nJSDoc\n := { ( \nid\n, )? ( \ndefs\n, )? \nJSch\n }\n\nid\n := \"id\": \"\nuri\n\"\n\ndefs\n := \"definitions\": { \nkSch (, kSch)\n*}\n\nkSch\n := \nkword\n: { \nJSch\n }\n\nJSch\n := ( \nres\n (, \nres\n)*)\n\nres\n := \ntype\n | \nstrRes\n | \nnumRes\n | \narrRes\n | \nobjRes\n | \nmultRes\n | \nrefSch\n | \ntitle\n | \ndescription\n\n\ntype\n := \"type\" : ([\ntypename\n (, \ntypename\n)*] | \ntypename\n)\n\ntypename\n := \"string\" | \"integer\" | \"number\" | \"boolean\" | \"null\" | \"array\" | \"object\"\n\ntitle\n := \"title\":  \nstring\n\n\ndescription\n := \"description\":  \nstring\n\n\n \n\n\nHere each \nres\n and \ntypename\n must be different from each other(otherwise they would be superfluous). We must also note that each \nkword\n is representing a keyword that must be unique in the nest level that is occurs. Besides, \nstring\n is any string to describe either the title or de description of the nested schema. Finally, a \nuri\n is any possible uri as defined in the \nstandard\n. Next we specify the remaining restrictions: \nstrRes\n, \nnumRes\n, \narrRes\n, \nobjRes\n and \nmultRes\n, as well as referred schemas \nrefSch\n.\n\n\nString Restrictions\n\n\n\n\nstrRes\n :=  \nminLen\n | \nmaxLen\n | \npattern\n\n\nminLen\n := \"minLength\": \nn\n\n\nmaxLen\n := \"maxLength\": \nn\n\n\npattern\n := \"pattern\": \"\nregExp\n\"\n\n\n\n\nHere \nn\n is a natural number and \nr\n is a regular expression.\n\n\nNumeric Restrictions\n\n\n\n\nnumRes\n := \nmin\n | \nmax\n | \nmultiple\n \n\nmin\n := \"minimum\": \nr\n (,\nexMin\n)?\n\nexMin\n := \"exclusiveMinimum\": \nbool\n\n\nmax\n := \"maximum\": \nr\n (,\nexMax\n)?\n\nexMax\n := \"exclusiveMaximum\": \nbool\n\n\nmultiple\n := \"multipleOf\": \nr\n   (\nr\n >= 0)\n\n\n\n\nHere \nr\n is a decimal number and \nbool\n is either true or false. \n\n\nArray Restrictions\n\n\n\n \narrRes\n := \nitems\n | \nadditems\n | \nminitems\n | \nmaxitems\n  | \nunique\n\n \nitems\n := ( \nsameitems\n |  \nvaritems\n )\n \nsameitems\n := \"items\": { \nJSch\n }\n \nvaritems\n := \"items\": [{ \nJSch\n }(,{ \nJSch\n })*] \n \nadditems\n :=  \"additionalItems\": (\nbool\n | { \nJSch\n })\n \nminitems\n := \"minItems\": \nn\n\n \nmaxitems\n := \"maxItems\": \nn\n\n \nunique\n := \"uniqueItems\": \nbool\n\n\n\n\n\nHere \nn\n is a natural number and \nbool\n is either true or false.\n\n\nObject Restrictions\n\n\n\n\nobjRes\n := \nprop\n | \naddprop\n | \nreq\n | \nminprop\n | \nmaxprop\n | \ndep\n | \npattprop\n\n\nprop\n := \"properties\": { \nkSch\n (, \nkSch\n)*}\n\nkSch\n := \nkword\n: { \nJSch\n }\n\naddprop\n := \"additionalProperties\": (\nbool\n | { \nJSch\n })\n\nreq\n := \"required\": [ \nkword\n (, \nkword\n)*]\n\nminprop\n := \"minProperties\": \nn\n\n\nmaxprop\n := \"maxProperties\": \nn\n\n\ndep\n := \"dependencies\": { \nkDep\n (, \nkDep\n)*}\n\nkDep\n := (\nkArr\n | \nkSch\n)\n\nkArr\n := \nkword\n: [ \nkword\n (, \nkword\n)*]\n\npattprop\n := \"patternProperties\": { \npatSch\n (, \npatSch\n)*}\n\npatSch\n := \"\nregExp\n\": { \nJSch\n }\n\n\n\n\nHere \nn\n is a natural number, \nbool\n is either true or false and \nregExp\n is a regular expression. As above, each \nkword\n is representing a keyword that must be unique in the nest level that is occurs.\n\n\nMultiple Restrictions\n\n\n\n\nmultRes\n := \nallOf\n | \nanyOf\n| \noneOf\n | \nnot\n | \nenum\n\n\nanyOf\n := \"anyOf\": [ { \nJSch\n } (, { \nJSch\n }) * ]\n\nallOf\n := \"allOf\": [ { \nJSch\n } (, { \nJSch\n }) * ]\n\noneOf\n := \"oneOf\": [ { \nJSch\n } (, { \nJSch\n }) * ]\n\nnot\n := \"not\": { \nJSch\n }\n\nenum\n := \"enum\": [\nJval\n (, \nJval\n)*]\n\n\n\nHere \nJval\n is either a \nstring\n, \nnumber\n, \narray\n, \nobject\n, \nbool\n or a \nnull\n  value. Moreover each \nJval\n must be different from each other(otherwise they would be superfluous).\n\n\nReferred Schemas\n\n\nNote that \nuriRef\n below is the same grammar we defined earlier for URIs. \n\n\n\nrefSch\n := \"$ref\": \"\nuriRef\n\" \n\nuriRef\n := ( \naddress\n )? ( # / \nJPointer\n )?\n\nJPointer\n := ( / \npath\n )\n\n\npath\n := ( \nunescaped\n | \nescaped\n )\n\n\nescaped\n := ~0 | ~1\n\n\n\nWhere \nunescaped\n can be any character except for \n/\n and \n~\n. Also, \naddress\n corresponds to any URI that does not use the \n#\n symbol, or more precisely to any URI-reference constructed using the following grammar, as defined in the \nofficial standard\n:\n\n\n\naddress\n = (\nscheme\n : )? \nhier-part\n (? \nquery\n ) \n\n\n\nWell Formedness\n\n\nThe grammar above allow for some problematic schemas that need to be left out using a notion that we call \nwell formedness\n. \n\n\nAs an example of a problematic schema, consider the following: \n\n{\n    \"definitions\": {\n        \"Schema1\": {\n            \"not\": {\"$ref\": \"#/definitions/Schema1\"}\n        }\n    },\n    \"$ref\": \"#/definitions/Schema1\"       \n\n}\n\n\nThe above defines a Schema that is both S and not S at the same time! \n\n\nLet \nS\n be a JSON Schema document, and let \nS\n1\n,...,\nS\nn\n be all the schemas retrieved by any JSON Pointer inside \nS\n.  The \nreference graph\n of S is a directed graph whose set of nodes is {\nS\n1\n,...,\nS\nn\n} and where there is an edge from \nS\ni\n to \nS\nj\n if \nS_i\n is a boolean combination of schemas and at least one of those schemas corresponds to the JSON Pointer that retrieves \nS\nj\n. For instance, the graph of the document above has only one node, corresponding to the subschema defined under \n\"Schema1\"\n, and the only edge is a self loop on this node. Edges are only added if \nS\ni\n is a boolean combination of schemas, not if, for example, \nS\ni\n is an object and a reference inside a \n\"properties\"\n keyword retrieves \nS\nj\n.\n\n\nWe say that \nS\n is a well formed Schema if the reference graph of \nS\n is acyclic. \n\n\nWe propose to add the well formedness condition to the Schema, and we assume that all schemas are well formed whenever we talk about conformance to this document.", 
            "title": "Syntax"
        }, 
        {
            "location": "/spec/grammar/#syntax", 
            "text": "A more formal description of how JSON Schemas are built  In this section we define how every JSON Document can be built using a formal grammar. The purpose of this is to have a rigurous specification for JSON documents and to enable the community to solve ambiguities about each operator and type.", 
            "title": "Syntax"
        }, 
        {
            "location": "/spec/grammar/#notation", 
            "text": "The Formal Grammar in this specification is given using a simple, visual-based Extended Backus-Naur Form (EBNF) notation, that we define below.   Each rule in the grammar defines one symbol, in the form   symbol  := expression  For readability we always write non-terminal symbols in blackened font, such as  JSch  or  strRes . The expression on the right hand side of these rules may match more than one string, and is constructed according to the following operators:    string  any non-blackened string that does not use   ) ,  ( ,   |  or  ?  matches precisely against the string.    We also use brackets, as in  (expression) , to specify that the expression inside them is a unit. We can combine units using the following operators   E? : optional  E , mathces  E  or nothing  A | B :  A  or  B , matches either  A  or  B  A B   A  concatenated with  B , matches  A  followed by  B . This operator has higher precedence over  |    E* : Matches zero or more ocurrences of  E . Also has a higher precedence over  |", 
            "title": "Notation"
        }, 
        {
            "location": "/spec/grammar/#grammar", 
            "text": "Formally we define a JSON Schema Document as a set of definitions and a JSON Schema. Each JSON Schema is threated as a set of restrictions that may apply to one or more types. To keep a clean and tidy grammar we divide each restriction in different sections, but as every grammar, the document is defined by the union of all these nested variables.  Json Documents and Schemas  Let  JDOC  be an arbitrary JSON Schema Document. We can define its syntax using the following grammar:\n   JSDoc  := { (  id , )? (  defs , )?  JSch  } id  := \"id\": \" uri \" defs  := \"definitions\": {  kSch (, kSch) *} kSch  :=  kword : {  JSch  } JSch  := (  res  (,  res )*) res  :=  type  |  strRes  |  numRes  |  arrRes  |  objRes  |  multRes  |  refSch  |  title  |  description  type  := \"type\" : ([ typename  (,  typename )*] |  typename ) typename  := \"string\" | \"integer\" | \"number\" | \"boolean\" | \"null\" | \"array\" | \"object\" title  := \"title\":   string  description  := \"description\":   string     Here each  res  and  typename  must be different from each other(otherwise they would be superfluous). We must also note that each  kword  is representing a keyword that must be unique in the nest level that is occurs. Besides,  string  is any string to describe either the title or de description of the nested schema. Finally, a  uri  is any possible uri as defined in the  standard . Next we specify the remaining restrictions:  strRes ,  numRes ,  arrRes ,  objRes  and  multRes , as well as referred schemas  refSch .  String Restrictions   strRes  :=   minLen  |  maxLen  |  pattern  minLen  := \"minLength\":  n  maxLen  := \"maxLength\":  n  pattern  := \"pattern\": \" regExp \"  Here  n  is a natural number and  r  is a regular expression.  Numeric Restrictions   numRes  :=  min  |  max  |  multiple   min  := \"minimum\":  r  (, exMin )? exMin  := \"exclusiveMinimum\":  bool  max  := \"maximum\":  r  (, exMax )? exMax  := \"exclusiveMaximum\":  bool  multiple  := \"multipleOf\":  r    ( r  >= 0)  Here  r  is a decimal number and  bool  is either true or false.   Array Restrictions  \n  arrRes  :=  items  |  additems  |  minitems  |  maxitems   |  unique \n  items  := (  sameitems  |   varitems  )\n  sameitems  := \"items\": {  JSch  }\n  varitems  := \"items\": [{  JSch  }(,{  JSch  })*] \n  additems  :=  \"additionalItems\": ( bool  | {  JSch  })\n  minitems  := \"minItems\":  n \n  maxitems  := \"maxItems\":  n \n  unique  := \"uniqueItems\":  bool   Here  n  is a natural number and  bool  is either true or false.  Object Restrictions   objRes  :=  prop  |  addprop  |  req  |  minprop  |  maxprop  |  dep  |  pattprop  prop  := \"properties\": {  kSch  (,  kSch )*} kSch  :=  kword : {  JSch  } addprop  := \"additionalProperties\": ( bool  | {  JSch  }) req  := \"required\": [  kword  (,  kword )*] minprop  := \"minProperties\":  n  maxprop  := \"maxProperties\":  n  dep  := \"dependencies\": {  kDep  (,  kDep )*} kDep  := ( kArr  |  kSch ) kArr  :=  kword : [  kword  (,  kword )*] pattprop  := \"patternProperties\": {  patSch  (,  patSch )*} patSch  := \" regExp \": {  JSch  }  Here  n  is a natural number,  bool  is either true or false and  regExp  is a regular expression. As above, each  kword  is representing a keyword that must be unique in the nest level that is occurs.  Multiple Restrictions   multRes  :=  allOf  |  anyOf |  oneOf  |  not  |  enum  anyOf  := \"anyOf\": [ {  JSch  } (, {  JSch  }) * ] allOf  := \"allOf\": [ {  JSch  } (, {  JSch  }) * ] oneOf  := \"oneOf\": [ {  JSch  } (, {  JSch  }) * ] not  := \"not\": {  JSch  } enum  := \"enum\": [ Jval  (,  Jval )*]  Here  Jval  is either a  string ,  number ,  array ,  object ,  bool  or a  null   value. Moreover each  Jval  must be different from each other(otherwise they would be superfluous).  Referred Schemas  Note that  uriRef  below is the same grammar we defined earlier for URIs.   refSch  := \"$ref\": \" uriRef \"  uriRef  := (  address  )? ( # /  JPointer  )? JPointer  := ( /  path  )  path  := (  unescaped  |  escaped  )  escaped  := ~0 | ~1  Where  unescaped  can be any character except for  /  and  ~ . Also,  address  corresponds to any URI that does not use the  #  symbol, or more precisely to any URI-reference constructed using the following grammar, as defined in the  official standard :  address  = ( scheme  : )?  hier-part  (?  query  )", 
            "title": "Grammar"
        }, 
        {
            "location": "/spec/grammar/#well-formedness", 
            "text": "The grammar above allow for some problematic schemas that need to be left out using a notion that we call  well formedness .   As an example of a problematic schema, consider the following:  {\n    \"definitions\": {\n        \"Schema1\": {\n            \"not\": {\"$ref\": \"#/definitions/Schema1\"}\n        }\n    },\n    \"$ref\": \"#/definitions/Schema1\"        \n}  The above defines a Schema that is both S and not S at the same time!   Let  S  be a JSON Schema document, and let  S 1 ,..., S n  be all the schemas retrieved by any JSON Pointer inside  S .  The  reference graph  of S is a directed graph whose set of nodes is { S 1 ,..., S n } and where there is an edge from  S i  to  S j  if  S_i  is a boolean combination of schemas and at least one of those schemas corresponds to the JSON Pointer that retrieves  S j . For instance, the graph of the document above has only one node, corresponding to the subschema defined under  \"Schema1\" , and the only edge is a self loop on this node. Edges are only added if  S i  is a boolean combination of schemas, not if, for example,  S i  is an object and a reference inside a  \"properties\"  keyword retrieves  S j .  We say that  S  is a well formed Schema if the reference graph of  S  is acyclic.   We propose to add the well formedness condition to the Schema, and we assume that all schemas are well formed whenever we talk about conformance to this document.", 
            "title": "Well Formedness"
        }, 
        {
            "location": "/spec/semantics/", 
            "text": "Semantics\n\n\nA formal specification of how JSON Documents validate against a JSON Schema Document\n\n\nIn this section we present a formal specification of how JSON Schema restrictions are validated against an arbitraty JSON Document. The following rules for formal validations are general, and thus there is no difference between those schemas whose type is specified and that whose type is not specified. \n\n\nBut before specifying the semantics for these validation instances we must define a couple of structures first.\n\n\nDefinitions\n\n\nLet \nJ\n be a JSON document. We say that a keyword \nk\n appears in \nJ\n is \nJ\n contains a key:value pair of the form \nk: j'\n, for some document \nj'\n. \n\n\nFor a JSON Schema \nS\n, we use \nproperties(S)\n to denote all keywords \nk\n1\n, ..., k\nn\n that appear in the key-value pair of the form \n\"properties\": {k\n1\n: s\n1\n , ... , k\nn\n: s\nn\n}\n in \nS\n. The set \nproperties(S)\n is empty if the keyword properties does not appear in \nS\n. Likewise, we use \npatternProperties(S)\n to denote all keywords \nk\n1\n, ..., k\nn\n that appear in the key-value pair of the form \n\"patternProperties\": {k\n1\n: s\n1\n , ... , k\nn\n: s\nn\n}\n in \nS\n. The set \npatternProperties(S)\n is empty if the keyword properties does not appear in \nS\n.\n\n\nNext, consider the following compatibility table:\n\n\n\n\n\n\n\n\ntype\n\n\ncompatible keywords\n\n\n\n\n\n\n\n\n\n\nstring\n\n\n\"type\", \"minLength\", \"maxLength\",  \"pattern\"\n\n\n\n\n\n\nnumber\n\n\n\"type\", \"minimum\", \"maximum\", \"exclusiveMinimum\", \"exclusiveMaximum\", \"multipleOf\"\n\n\n\n\n\n\ninteger\n\n\n\"type\", \"minimum\", \"maximum\", \"exclusiveMinimum\", \"exclusiveMaximum\", \"multipleOf\"\n\n\n\n\n\n\nboolean\n\n\n\"type\"\n\n\n\n\n\n\nnull\n\n\n\"type\"\n\n\n\n\n\n\narray\n\n\n\"type\", \"minItems\", \"maxItems\", \"items\", \"uniqueItems\"\n\n\n\n\n\n\nobject\n\n\n\"type\", \"properties\", \"additionalProperties\", \"required\", \"minProperties\", \"maxProperties\", \"dependencies\", \"patternProperties\".\n\n\n\n\n\n\n\n\nWe define the function \nCompatible(J,k)\n as the function that receives a JSON document \nJ\n and a key/value pair \nk\n of the form \nkey: value\n and returns \ntrue\n if \nkey\n is a string in the following list:\n\n\n\n\n\n\n\n\nlist of keywords\n\n\n\n\n\n\n\n\n\n\n\"type\", \"minLength\", \"maxLength\",  \"pattern\", \"minimum\", \"maximum\", \"exclusiveMinimum\", \"exclusiveMaximum\", \"multipleOf\", \"minItems\", \"maxItems\", \"items\", \"uniqueItems\", \"properties\", \"additionalProperties\", \"required\", \"minProperties\", \"maxProperties\", \"dependencies\", \"patternProperties\".\n\n\n\n\n\n\n\n\nand \nkey\n is compatible with the type of \nJ\n according to the compatibility table above. Otherwise, \nCompatible(J,k)\n returns \nfalse\n. For instance, \nCompatible(42,\"multipleOf\": 7) = true\n, while \nCompatible(42,\"minitems\": 4) = false\n.\n\n\nJSON Reference\n\n\nIf \npath\n is a JSON pointer, we say that \nrep(path)\n is the string resulting of replacing first each character \n~1\n by \n/\n and then each character \n~0\n by \n~\n.\n\n\nGiven a JSON document \nJ\n that is an object, we use \nJ[k]\n (for a string \nk\n) to represent the value of the key value pair in \nJ\n whose key is \nk\n. Likewise, if \nJ\n is an array, then \nJ[n]\n (for a natural number \nn\n) corresponds to the \nn\n-th element of \nJ\n. \n\n\nLet \nJ\n be a JSON document. JSON Pointers are intended to extract a part of \nJ\n that is specifically indexed by the pointer. Formally, we define the function \nEVAL()\n that takes a JSON Document \nJ\n and a JSON Pointer \nJPointer\n and delivers a subset of \nJ\n: \n\n\n\n\nEVAL(J,JPointer)\n returns: \n\n\n\n\n\n\nJ\n, if \nJPointer\n is the empty string\n, or \n\n\n\n\n\n\nEVAL(J[rep(key)],JP)\n, if \nJ\n is an object, \nrep(key)\n appears in \nJ\n and \nJPointer\n is of the form \nJP/key\n, or\n\n\n\n\nEVAL(J[n],JP)\n, if \nJPointer\n is an array with at least \nn+1\n objects and \nJPointer\n is of the form \nJP/n\n, where \nn\n is the base-10 representation of a natural number, or\n\n\nan error in any other case (for example when the pointer asks for a key that is not in \nJ\n). \n\n\n\n\nLet \nR\n be a JSON Reference of the form \n\"$ref\": uriRef\n. We extend the function \nEVAL()\n to work with arbitrary JSON references. We do it as follows. \n\n\nEVAL(J,R)\n returns: \n\n\n\n\n\n\nEVAL(J,JPointer)\n, if \nuriRef\n is of the form \n#/JPointer\n, or \n\n\n\n\n\n\nS\n, if \nuriRef\n does not contains the symbol \n#\n and the address in \nuriRef\nsuccesfully retrieves the schema \nS\n, or \n\n\n\n\n\n\nEVAL(S,JPointer)\n, if \nuriRef\n is of the form \naddress#/JPointer\n and the address in \nuriRef\nsuccesfully retrieves the schema \nS\n, or \n\n\n\n\n\n\nan error in any other case (for example when the address retrieves something that is not a schema). \n\n\n\n\n\n\nLet \nR\n be again a JSON Reference and \nJ\n a JSON document. Assume that the JSON schema document that contains \nR\n is \nS\n. Then we say that \nJ\n validates against \nR\n under \nS\n if \nEVAL(S,R)\n returns a schema (not an error) and \nJ\n validates against \nEVAL(S,R)\n.\n\n\nValidation\n\n\nLet \nS\n be a JSON Schema and \nJ\n a JSON document, and assume that the JSON schema document that contains \nS\n is \nD\n. We say that \nJ\n validates against \nS\n if one of the following holds: \n\n\n\n\n\n\nOne of the key:value pairs in \nS\n is a JSON reference \nR\n, and \nJ\n validates against \nR\n under \nD\n. \n\n\n\n\n\n\nS\n does not contain a JSON Reference, and for each key:value pair \nk\n in \nS\n such that \nCompatible(J,k) = true\n we have that \nJ\n validates against \nk\n under \nS\n. \n\n\n\n\n\n\nNote how we make a special case when \nJ\n is a JSON reference. In this case, but only if the reference sucessfully retrieves a schema, we ignore all the remaining keywords, and just validate against the schema retrieved by the reference. On the other hand, no document validates agains a reference that returns an error (simply because in this case it is not possible to instantiate the schema)\n\n\nIn turn, let \nS\n be a JSON schema, \nk\n be a key:value pair in \nS\n and \nJ\n a JSON document. We say that \nJ\n validates against \nk\n under \nS\n if one of the following holds: \n\n\nGeneral Restrictions\n\n\n\n\nk\n is \n\"type\": \"string\"\n and \nJ\n is a string.\n\n\nk\n is \n\"type\": \"number\"\n and \nJ\n is a number.\n\n\nk\n is \n\"type\": \"integer\"\n and \nJ\n is an integer.\n\n\nk\n is \n\"type\": \"boolean\"\n and \nJ\n is a boolean value.\n\n\nk\n is \n\"type\": \"null\"\n and \nJ\n is the value null.\n\n\nk\n is \n\"type\": \"array\"\n and \nJ\n is an array.\n\n\nk\n is \n\"type\": \"object\"\n and \nJ\n is an object.\n\n\nk\n is \n\"type: [t\n1\n, ... ,t\nn\n]\"\n and the type of \nJ\n is \nt\ni\n for some \nt\ni\n in \n{ t\n1\n,  ...,  t\nn\n }\n.\n\n\nk\n is \n\"enum\": [j\n1\n, ... ,j\nn\n] \n and \nJ\n = \nj\ni\n for some \nj\ni\n in \n{ j\n1\n,  ...,  j\nn\n }\n.\n\n\n\n\nStrings Restrictions\n\n\n\n\nk\n is of the form \n\"minLength\" : n\n and \nJ\n is a string of length at least \nn\n.\n\n\nk\n is of the form \n\"maxLength\" : n\n and \nJ\n is a string of length at most \nn\n.\n\n\nk\n is of the form \n\"pattern\" : \"rexp\"\n and \nJ\n is a string that matches the regular expression rexp.\n\n\n\n\nNumeric Restrictions\n\n\n\n\nk\n is \n\"multipleOf\": r\n for some positive decimal number \nr\n, and \nJ\n is a number that is a multpiple of \nr\n.\n\n\nk\n is \n\"minimum\": r\n for some decimal \nr\n, and \nJ\n is a number that is strictly greater than \nr\n.\n\n\nk\n is \n\"minimum\": r\n for some decimal \nr\n,  \nJ\n is a number that is equal to \nr\n and the pair \n\"exclusiveMinimum\": true\n is not in \nS\n.\n\n\nk\n is \n\"maximum\": r\n, for some decimal  \nr\n, and \nJ\n is a number that is stricly less than \nr\n.\n\n\nk\n is \n\"maximum\": r\n for some decimal \nr\n,  \nJ\n is a number that is equal to \nr\n and the pair \n\"exclusiveMinimum\": true\n is not in \nS\n.\n\n\n\n\nArrays Restrictions\n\n\n\n\nk\n is \n\"items\": S'\n and \nJ\n is an array such that every element validates against S'.\n\n\nk\n is \n\"items\": [s\n1\n , ... , s\nn\n]\n and \nJ\n is an array \n[a\n1\n , ... , a\nm\n]\n such that every element \na\ni\n validates against \ns\ni\n with \ni\n \u2264 Min(m,n).\n\n\nk\n is \n\"additionalItems\": true\n and \nJ\n is an array.\n\n\nk\n is \n\"additionalItems\": false\n, there is a key:value pair \n\"items\": [s\n1\n , ... , s\nn\n]\n in \nS\n and \nJ\n is an array with at most n elements. \n\n\nk\n is \n\"additionalItems\": false\n, and either \nS\n does not contain a pair with keyword \n\"items\"\n, or such pair is of the form \n\"items\": S'\n (that is, the value of items is an object, not an array). \n\n\nk\n is \n\"additionalItems\": S'\n, \nS\n does not contain a pair with keyword \n\"items\"\n and \nJ\n is an array such that every element validates against S'.\n\n\nk\n is \n\"additionalItems\": S'\n and \nS\n contains a pair of the form \n\"items\": S'\n (that is, the value of items is an object, not an array). \n\n\nk\n is \n\"additionalItems\": S'\n, \nS\n has a pair of form \n\"items\": [s\n1\n , ... , s\nn\n]\n, and \nJ\n is an array \n[a\n1\n , ... , a\nm\n]\n such that each a\ni\n, for i \n n, validates against \nS'\n. \n\n\nk\n is \n\"minItems\": n\n and \nJ\n is an array with at least n elements.\n\n\nk\n is \n\"maxItems\": n\n and \nJ\n is an array with at most n elements.\n\n\nk\n is \n\"uniqueItems\": true\n and \nJ\n is an array with all elements different from each other.\n\n\n\n\nObject Restrictions\n\n\n\n\nk\n is of the form \n\"properties\": {k\n1\n: s\n1\n , ... , k\nn\n: s\nn\n}\n and \nJ\n is an object that for each key-value pair \nk': j'\n in \nJ\n, if \nk' = k\ni\n for some \ni\n in [ \n1\n , ... , \nn\n ] then \nj'\n satisfies \ns\ni\n.\n\n\nk\n is of the form \n\"patternProperties\": {rexp\n1\n: s\n1\n , ... , rexp\nn\n: s\nn\n}\n and \nJ\n is an object such that for each key-value pair \nk': j'\n in \nJ\n and \nevery rexp\ni\n, i in [ \n1\n , ... , \nn\n ], such that \nk'\n is in the language of rexp\ni\n, then \n\nj'\n satisfies \ns\ni\n.\n\n\nk\n is of the form \n\"required\": [k\n1\n , ... , k\nn\n]\n and each \nk\ni\n appears in \nJ\n. \n\n\nk\n is of the form \n\"minProperties\": n\n and \nJ\n is an object with at least \nn\n key:value pairs.\n\n\nk\n is of the form \n\"maxProperties\": n\n and \nJ\n is an object with at most \nn\n key:value pairs.\n\n\nk\n is of the form \n\"additionalProperties\": false\n and \nJ\n is an object such that every keyword in \nJ\n either belongs to \nproperties(S)\n or matches at least one of the expressions in \npatternProperties(S)\n\n\nk\n is of the form \n\"additionalProperties\": true\n and \nJ\n is an object\n\n\nk\n is of the form \n\"additionalProperties\": S'\n and \nJ\n is an object such that for each key-value pair \nk': j'\n in \nJ\n, with \nk'\n not in \nproperties(S)\n and \nk'\n not matching any of the expressions in \npatternProperties(S)\n, we have that \nj'\n validates against \nS'\n\n\nk\n is of the form \n\"dependencies\": {k\n1\n: [l\n1,1\n , ... ,l\n1,m\n1\n], ... , k\nn\n: [l\nn,1\n , ... ,l\nn,m\nn\n]}\n and \nJ\n is an object such that if \nk\ni\n appears in \nJ\n then every keyword in \n[l\ni,1\n , ... ,l\ni,m\ni\n]\n appears in \nJ\n\n\nk\n is of the form \n\"dependencies\": {k\n1\n: s\n1\n , ... , k\nn\n: s\nn\n}\n  and \nJ\n is an object such that if \nk\ni\n appears in \nJ\n then \nJ\n must satisfy \ns\ni\n\n\n\n\nCombinations\n\n\n\n\nk\n is of the form \n\"anyOf\": [{Sch\n1\n}, {Sch\n2\n}, ... ,{Sch\nn\n}]\n and \nJ\n validates against \nsome\n \nSch\ni\n, for \ni\n=\n1\n...\nn\n\n\nk\n is of the form \n\"allOf\": [{Sch\n1\n}, {Sch\n2\n}, ... ,{Sch\nn\n}]\n and \nJ\n validates against \nall\n of \nSch\ni\n, for \ni\n=\n1\n...\nn\n\n\nk\n is of the form \n\"oneOf\": [{Sch\n1\n}, {Sch\n2\n}, ... ,{Sch\nn\n}]\n and \nJ\n validates against \nexactly one\n of \nSch\ni\n, for \ni\n=\n1\n...\nn\n\n\nk\n is of the form \n\"not\": {Sch}\n and \nJ\n does \nnot\n validate against \nSch", 
            "title": "Semantics"
        }, 
        {
            "location": "/spec/semantics/#semantics", 
            "text": "A formal specification of how JSON Documents validate against a JSON Schema Document  In this section we present a formal specification of how JSON Schema restrictions are validated against an arbitraty JSON Document. The following rules for formal validations are general, and thus there is no difference between those schemas whose type is specified and that whose type is not specified.   But before specifying the semantics for these validation instances we must define a couple of structures first.  Definitions  Let  J  be a JSON document. We say that a keyword  k  appears in  J  is  J  contains a key:value pair of the form  k: j' , for some document  j' .   For a JSON Schema  S , we use  properties(S)  to denote all keywords  k 1 , ..., k n  that appear in the key-value pair of the form  \"properties\": {k 1 : s 1  , ... , k n : s n }  in  S . The set  properties(S)  is empty if the keyword properties does not appear in  S . Likewise, we use  patternProperties(S)  to denote all keywords  k 1 , ..., k n  that appear in the key-value pair of the form  \"patternProperties\": {k 1 : s 1  , ... , k n : s n }  in  S . The set  patternProperties(S)  is empty if the keyword properties does not appear in  S .  Next, consider the following compatibility table:     type  compatible keywords      string  \"type\", \"minLength\", \"maxLength\",  \"pattern\"    number  \"type\", \"minimum\", \"maximum\", \"exclusiveMinimum\", \"exclusiveMaximum\", \"multipleOf\"    integer  \"type\", \"minimum\", \"maximum\", \"exclusiveMinimum\", \"exclusiveMaximum\", \"multipleOf\"    boolean  \"type\"    null  \"type\"    array  \"type\", \"minItems\", \"maxItems\", \"items\", \"uniqueItems\"    object  \"type\", \"properties\", \"additionalProperties\", \"required\", \"minProperties\", \"maxProperties\", \"dependencies\", \"patternProperties\".     We define the function  Compatible(J,k)  as the function that receives a JSON document  J  and a key/value pair  k  of the form  key: value  and returns  true  if  key  is a string in the following list:     list of keywords      \"type\", \"minLength\", \"maxLength\",  \"pattern\", \"minimum\", \"maximum\", \"exclusiveMinimum\", \"exclusiveMaximum\", \"multipleOf\", \"minItems\", \"maxItems\", \"items\", \"uniqueItems\", \"properties\", \"additionalProperties\", \"required\", \"minProperties\", \"maxProperties\", \"dependencies\", \"patternProperties\".     and  key  is compatible with the type of  J  according to the compatibility table above. Otherwise,  Compatible(J,k)  returns  false . For instance,  Compatible(42,\"multipleOf\": 7) = true , while  Compatible(42,\"minitems\": 4) = false .  JSON Reference  If  path  is a JSON pointer, we say that  rep(path)  is the string resulting of replacing first each character  ~1  by  /  and then each character  ~0  by  ~ .  Given a JSON document  J  that is an object, we use  J[k]  (for a string  k ) to represent the value of the key value pair in  J  whose key is  k . Likewise, if  J  is an array, then  J[n]  (for a natural number  n ) corresponds to the  n -th element of  J .   Let  J  be a JSON document. JSON Pointers are intended to extract a part of  J  that is specifically indexed by the pointer. Formally, we define the function  EVAL()  that takes a JSON Document  J  and a JSON Pointer  JPointer  and delivers a subset of  J :    EVAL(J,JPointer)  returns:     J , if  JPointer  is the empty string , or     EVAL(J[rep(key)],JP) , if  J  is an object,  rep(key)  appears in  J  and  JPointer  is of the form  JP/key , or   EVAL(J[n],JP) , if  JPointer  is an array with at least  n+1  objects and  JPointer  is of the form  JP/n , where  n  is the base-10 representation of a natural number, or  an error in any other case (for example when the pointer asks for a key that is not in  J ).    Let  R  be a JSON Reference of the form  \"$ref\": uriRef . We extend the function  EVAL()  to work with arbitrary JSON references. We do it as follows.   EVAL(J,R)  returns:     EVAL(J,JPointer) , if  uriRef  is of the form  #/JPointer , or     S , if  uriRef  does not contains the symbol  #  and the address in  uriRef succesfully retrieves the schema  S , or     EVAL(S,JPointer) , if  uriRef  is of the form  address#/JPointer  and the address in  uriRef succesfully retrieves the schema  S , or     an error in any other case (for example when the address retrieves something that is not a schema).     Let  R  be again a JSON Reference and  J  a JSON document. Assume that the JSON schema document that contains  R  is  S . Then we say that  J  validates against  R  under  S  if  EVAL(S,R)  returns a schema (not an error) and  J  validates against  EVAL(S,R) .", 
            "title": "Semantics"
        }, 
        {
            "location": "/spec/semantics/#validation", 
            "text": "Let  S  be a JSON Schema and  J  a JSON document, and assume that the JSON schema document that contains  S  is  D . We say that  J  validates against  S  if one of the following holds:     One of the key:value pairs in  S  is a JSON reference  R , and  J  validates against  R  under  D .     S  does not contain a JSON Reference, and for each key:value pair  k  in  S  such that  Compatible(J,k) = true  we have that  J  validates against  k  under  S .     Note how we make a special case when  J  is a JSON reference. In this case, but only if the reference sucessfully retrieves a schema, we ignore all the remaining keywords, and just validate against the schema retrieved by the reference. On the other hand, no document validates agains a reference that returns an error (simply because in this case it is not possible to instantiate the schema)  In turn, let  S  be a JSON schema,  k  be a key:value pair in  S  and  J  a JSON document. We say that  J  validates against  k  under  S  if one of the following holds:   General Restrictions   k  is  \"type\": \"string\"  and  J  is a string.  k  is  \"type\": \"number\"  and  J  is a number.  k  is  \"type\": \"integer\"  and  J  is an integer.  k  is  \"type\": \"boolean\"  and  J  is a boolean value.  k  is  \"type\": \"null\"  and  J  is the value null.  k  is  \"type\": \"array\"  and  J  is an array.  k  is  \"type\": \"object\"  and  J  is an object.  k  is  \"type: [t 1 , ... ,t n ]\"  and the type of  J  is  t i  for some  t i  in  { t 1 ,  ...,  t n  } .  k  is  \"enum\": [j 1 , ... ,j n ]   and  J  =  j i  for some  j i  in  { j 1 ,  ...,  j n  } .   Strings Restrictions   k  is of the form  \"minLength\" : n  and  J  is a string of length at least  n .  k  is of the form  \"maxLength\" : n  and  J  is a string of length at most  n .  k  is of the form  \"pattern\" : \"rexp\"  and  J  is a string that matches the regular expression rexp.   Numeric Restrictions   k  is  \"multipleOf\": r  for some positive decimal number  r , and  J  is a number that is a multpiple of  r .  k  is  \"minimum\": r  for some decimal  r , and  J  is a number that is strictly greater than  r .  k  is  \"minimum\": r  for some decimal  r ,   J  is a number that is equal to  r  and the pair  \"exclusiveMinimum\": true  is not in  S .  k  is  \"maximum\": r , for some decimal   r , and  J  is a number that is stricly less than  r .  k  is  \"maximum\": r  for some decimal  r ,   J  is a number that is equal to  r  and the pair  \"exclusiveMinimum\": true  is not in  S .   Arrays Restrictions   k  is  \"items\": S'  and  J  is an array such that every element validates against S'.  k  is  \"items\": [s 1  , ... , s n ]  and  J  is an array  [a 1  , ... , a m ]  such that every element  a i  validates against  s i  with  i  \u2264 Min(m,n).  k  is  \"additionalItems\": true  and  J  is an array.  k  is  \"additionalItems\": false , there is a key:value pair  \"items\": [s 1  , ... , s n ]  in  S  and  J  is an array with at most n elements.   k  is  \"additionalItems\": false , and either  S  does not contain a pair with keyword  \"items\" , or such pair is of the form  \"items\": S'  (that is, the value of items is an object, not an array).   k  is  \"additionalItems\": S' ,  S  does not contain a pair with keyword  \"items\"  and  J  is an array such that every element validates against S'.  k  is  \"additionalItems\": S'  and  S  contains a pair of the form  \"items\": S'  (that is, the value of items is an object, not an array).   k  is  \"additionalItems\": S' ,  S  has a pair of form  \"items\": [s 1  , ... , s n ] , and  J  is an array  [a 1  , ... , a m ]  such that each a i , for i   n, validates against  S' .   k  is  \"minItems\": n  and  J  is an array with at least n elements.  k  is  \"maxItems\": n  and  J  is an array with at most n elements.  k  is  \"uniqueItems\": true  and  J  is an array with all elements different from each other.   Object Restrictions   k  is of the form  \"properties\": {k 1 : s 1  , ... , k n : s n }  and  J  is an object that for each key-value pair  k': j'  in  J , if  k' = k i  for some  i  in [  1  , ... ,  n  ] then  j'  satisfies  s i .  k  is of the form  \"patternProperties\": {rexp 1 : s 1  , ... , rexp n : s n }  and  J  is an object such that for each key-value pair  k': j'  in  J  and \nevery rexp i , i in [  1  , ... ,  n  ], such that  k'  is in the language of rexp i , then  j'  satisfies  s i .  k  is of the form  \"required\": [k 1  , ... , k n ]  and each  k i  appears in  J .   k  is of the form  \"minProperties\": n  and  J  is an object with at least  n  key:value pairs.  k  is of the form  \"maxProperties\": n  and  J  is an object with at most  n  key:value pairs.  k  is of the form  \"additionalProperties\": false  and  J  is an object such that every keyword in  J  either belongs to  properties(S)  or matches at least one of the expressions in  patternProperties(S)  k  is of the form  \"additionalProperties\": true  and  J  is an object  k  is of the form  \"additionalProperties\": S'  and  J  is an object such that for each key-value pair  k': j'  in  J , with  k'  not in  properties(S)  and  k'  not matching any of the expressions in  patternProperties(S) , we have that  j'  validates against  S'  k  is of the form  \"dependencies\": {k 1 : [l 1,1  , ... ,l 1,m 1 ], ... , k n : [l n,1  , ... ,l n,m n ]}  and  J  is an object such that if  k i  appears in  J  then every keyword in  [l i,1  , ... ,l i,m i ]  appears in  J  k  is of the form  \"dependencies\": {k 1 : s 1  , ... , k n : s n }   and  J  is an object such that if  k i  appears in  J  then  J  must satisfy  s i   Combinations   k  is of the form  \"anyOf\": [{Sch 1 }, {Sch 2 }, ... ,{Sch n }]  and  J  validates against  some   Sch i , for  i = 1 ... n  k  is of the form  \"allOf\": [{Sch 1 }, {Sch 2 }, ... ,{Sch n }]  and  J  validates against  all  of  Sch i , for  i = 1 ... n  k  is of the form  \"oneOf\": [{Sch 1 }, {Sch 2 }, ... ,{Sch n }]  and  J  validates against  exactly one  of  Sch i , for  i = 1 ... n  k  is of the form  \"not\": {Sch}  and  J  does  not  validate against  Sch", 
            "title": "Validation"
        }, 
        {
            "location": "/spec/Differences_with_the_standard/", 
            "text": "Differences with the standard\n\n\nWe had to limit our notion of JSON Schema in order to make it more readable and user-friendly. Here are the differences between our grammar and the latest draft specification. \n\n\nJSON Schemas are JSON Documents.\n\n\nAnd we are assuming that JSON objects cannot have two values with the same keys. This is to avoid these types of examples, which will probably not work properly in several implementations:\n\n\n\n{\n    \"type\": \"string\",\n    \"type\": object\n}\n\n\n\n\nWe do not support the inclusion of additional keywords or items in schemas.\n\n\nEvery key and every value in the document must conform to the JSON Schema specification, and in particular we do not allow mixing schemas with other JSON information. We are aware that certain implementations may support schemas with additional non-schema information, but we believe this deeply complicates the examples and jeopardises the readability of JSON Schema documents. \n\n\nOur grammar clearly specifies an upper level, where a title and a description keywords can be defined, and with an optional definitions object (see below). The rest has to conform to JSON Schema specification. \n\n\nWe norm the use of a separate \u201cdefinitions\u201d section.\n\n\nThis is also an effort to reduce information overload in JSON schemas.  In all the schemas we have seen there is always a definitions object at the topmost level of the schema, and the rest of the document only references documents inside this definitions section. For this reason we decided to divide JSON schemas into two parts: a \"definitions\" object that contains several schemas under different keywords, and a schema object where all the schema keywords come in.\nIn other words, we mandate all schemas to have the following form: \n\n\n\n{\n    \"definitions\": {\n        \"Name1\": {\n            \n<\n a valid schema > \n        }, \n        \"Name2\": {\n            \n<\n another valid schema > \n        }, \n        .\n        .\n        .\n    },\n\n   .\n   .\n   Here comes the top level schema\n   .\n   .     \n}\n\n\n\n\n\nWe do not include the \"default\" keywords, nor any other way of specifying default values.\n\n\nWe don't think the use of \"default\" is clear enough in the specification, so we decided to leave out this functionality. To name just a few examples where the use of default is not clear, consider the following schemas: \n\n\n{\n    \"anyOf\": [\n        {\"type\": \"number\"}, \n        {\"type\": \"number\", \"default\":0}\n    ]\n}\n\n\n\nIs this equivalent to a number object whose default is 0? What about an \"anyOf\" schema? this is even more complicated when different default values are given:\n\n\n\n{\n    \"allOf\": [\n        {\"type\": \"number\", \"default\": 10}, \n        {\"type\": \"number\", \"default\":0}\n    ]\n}\n\n\n\n\nThese two are very specific examples, but the underlying problem is that the default keyword is not clear enough in the specification.  \n\n\nWe do not support $schema as a way of specifying the location of a schema.\n\n\nIn fact, we do not support the $schema keyword at all, but this is just to avoid different uses (for us it is just a uri specifying the address of the schema).\n\n\nWe rule out schemas that are not well formed.\n\n\nFrom our point of view JSON Schema validators should analyze whenever schemas are not well formed, and give a syntax error. This is why we rule out badly formed schemas in our syntax.", 
            "title": "About this grammar"
        }, 
        {
            "location": "/spec/Differences_with_the_standard/#differences-with-the-standard", 
            "text": "We had to limit our notion of JSON Schema in order to make it more readable and user-friendly. Here are the differences between our grammar and the latest draft specification.   JSON Schemas are JSON Documents.  And we are assuming that JSON objects cannot have two values with the same keys. This is to avoid these types of examples, which will probably not work properly in several implementations:  \n{\n    \"type\": \"string\",\n    \"type\": object\n}  We do not support the inclusion of additional keywords or items in schemas.  Every key and every value in the document must conform to the JSON Schema specification, and in particular we do not allow mixing schemas with other JSON information. We are aware that certain implementations may support schemas with additional non-schema information, but we believe this deeply complicates the examples and jeopardises the readability of JSON Schema documents.   Our grammar clearly specifies an upper level, where a title and a description keywords can be defined, and with an optional definitions object (see below). The rest has to conform to JSON Schema specification.   We norm the use of a separate \u201cdefinitions\u201d section.  This is also an effort to reduce information overload in JSON schemas.  In all the schemas we have seen there is always a definitions object at the topmost level of the schema, and the rest of the document only references documents inside this definitions section. For this reason we decided to divide JSON schemas into two parts: a \"definitions\" object that contains several schemas under different keywords, and a schema object where all the schema keywords come in.\nIn other words, we mandate all schemas to have the following form:   \n{\n    \"definitions\": {\n        \"Name1\": {\n             <  a valid schema > \n        }, \n        \"Name2\": {\n             <  another valid schema > \n        }, \n        .\n        .\n        .\n    },\n\n   .\n   .\n   Here comes the top level schema\n   .\n   .     \n}  We do not include the \"default\" keywords, nor any other way of specifying default values.  We don't think the use of \"default\" is clear enough in the specification, so we decided to leave out this functionality. To name just a few examples where the use of default is not clear, consider the following schemas:  \n{\n    \"anyOf\": [\n        {\"type\": \"number\"}, \n        {\"type\": \"number\", \"default\":0}\n    ]\n}  Is this equivalent to a number object whose default is 0? What about an \"anyOf\" schema? this is even more complicated when different default values are given:  \n{\n    \"allOf\": [\n        {\"type\": \"number\", \"default\": 10}, \n        {\"type\": \"number\", \"default\":0}\n    ]\n}  These two are very specific examples, but the underlying problem is that the default keyword is not clear enough in the specification.    We do not support $schema as a way of specifying the location of a schema.  In fact, we do not support the $schema keyword at all, but this is just to avoid different uses (for us it is just a uri specifying the address of the schema).  We rule out schemas that are not well formed.  From our point of view JSON Schema validators should analyze whenever schemas are not well formed, and give a syntax error. This is why we rule out badly formed schemas in our syntax.", 
            "title": "Differences with the standard"
        }, 
        {
            "location": "/spec/metaschema/", 
            "text": "Meta - Schema\n\n\nThe schema of all JSON schemas we allow.\n\n\nSince we are \nleaving out some general schemas\n in our specification, we present below a JSON Schema that represents all valid JSON schemas. The schema can be \n\ndownloaded here\n. \n\n\nMeta - Schema\n\n\nmeta_schema.json\n\n\n{\n  \"definitions\":{\n    \"JSDoc\":{\n      \"type\": \"object\",\n      \"properties\":{\n        \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uri\"\n        },\n        \"$schema\": {\n            \"type\": \"string\",\n            \"format\": \"uri\"\n        },\n        \"title\": {\n            \"type\": \"string\"\n        },\n        \"description\": {\n            \"type\": \"string\"\n        },\n        \"default\": {\n\n        },\n\n        \"definitions\": {\n          \"type\": \"object\",\n          \"additionalItems\": {\n            \"$ref\": \"#/definitions/JSDoc\"\n          }\n        },\n\n        \"type\":{\n      \"anyOf\":[\n        {\"$ref\": \"#/definitions/typename\"},\n        {\"type\": \"array\",\n        \"additionalItems\":{\n          \"$ref\": \"#/definitions/typename\"\n        }}\n      ]\n    },\n\n        \"allOf\":{\n          \"type\":\"array\",\n          \"items\":{\"$ref\":\"#/definitions/JSch\"}\n        },\n        \"anyOf\":{\n          \"type\":\"array\",\n          \"items\":{\"$ref\":\"#/definitions/JSch\"}\n        },\n        \"not\":{\n          \"type\":\"array\",\n          \"items\":{\"$ref\":\"#/definitions/JSch\"}\n        },\n        \"oneOf\":{\n          \"type\":\"array\",\n          \"items\":{\"$ref\":\"#/definitions/JSch\"}\n        },\n        \"enum\":{\n          \"type\":\"array\"\n        },\n\n        \"additionalProperties\": {\n          \"oneOf\": [\n            {\n              \"type\": \"boolean\"\n            },\n            {\n              \"$ref\": \"#/definitions/JSDoc\"\n            }\n          ]\n        },\n        \"minProperties\": {\n          \"type\": \"integer\"\n        },\n        \"maxProperties\": {\n          \"type\": \"integer\"\n        },\n        \"patternProperties\": {\n          \"type\": \"object\",\n          \"additionalProperties\":{\n            \"$ref\": \"#/definitions/JSDoc\"\n          }\n        },\n        \"properties\": {\n          \"type\": \"object\",\n          \"additionalProperties\":{\n            \"$ref\": \"#/definitions/JSDoc\"\n          }\n        },\n        \"required\": {\n          \"type\": \"array\",\n          \"items\": {\n            \"type\": \"string\"\n          }\n        },\n        \"dependencies\": {\n          \"$ref\": \"#/definitions/dep\"\n        },\n\n        \"items\":{\n          \"oneOf\":[\n            {\"$ref\":\"#/definitions/JSDoc\"},\n            {\n              \"type\":\"array\",\n              \"items\":{\n                \"$ref\":\"#/definitions/JSDoc\"\n              },\n              \"minItems\": 1\n            }\n          ]\n        },\n        \"additionalItems\":{\"anyOf\":[{\"type\":\"boolean\"}, {\"$ref\":\"#/definitions/schema\"}]},\n        \"minItems\":{\"type\":\"integer\"},\n        \"maxItems\":{\"type\":\"integer\"},\n        \"uniqueItems\":{\"type\":\"boolean\"},\n\n        \"minLength\":{\"type\":\"integer\"},\n        \"maxLength\":{\"type\":\"integer\"},\n        \"pattern\":{\"type\":\"string\"},\n        \"format\":{\"enum\":[\"date-time\",\"email\",\"hostname\",\"ipv4\",\"ipv6\",\"uri\"]},\n\n        \"multipleOf\": {\n          \"type\": \"number\"\n        },\n        \"minimum\": {\n          \"type\": \"number\"\n        },\n        \"maximum\": {\n          \"type\": \"number\"\n        },\n        \"exclusiveMinimum\": {\n          \"type\": \"boolean\"\n        },\n        \"exclusiveMaximum\": {\n          \"type\": \"boolean\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"typename\":{\n      \"enum\": [\"string\", \"integer\", \"number\", \"boolean\", \"null\", \"array\", \"object\"]\n    },\n    \"dep\":{\n      \"type\": \"object\",\n      \"additionalProperties\":{\n        \"anyOf\":[\n          {\"$ref\": \"#/definitions/JSDoc\"},\n          {\"$ref\": \"#/definitions/depArr\"}\n        ]\n      }\n    },\n    \"depArr\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"string\"\n      }\n    }\n  },\n  \"$ref\":\"#/definitions/JSDoc\"\n}}", 
            "title": "Meta Schema"
        }, 
        {
            "location": "/spec/metaschema/#meta-schema", 
            "text": "The schema of all JSON schemas we allow.  Since we are  leaving out some general schemas  in our specification, we present below a JSON Schema that represents all valid JSON schemas. The schema can be  downloaded here .", 
            "title": "Meta - Schema"
        }, 
        {
            "location": "/spec/metaschema/#meta-schema_1", 
            "text": "meta_schema.json  {\n  \"definitions\":{\n    \"JSDoc\":{\n      \"type\": \"object\",\n      \"properties\":{\n        \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uri\"\n        },\n        \"$schema\": {\n            \"type\": \"string\",\n            \"format\": \"uri\"\n        },\n        \"title\": {\n            \"type\": \"string\"\n        },\n        \"description\": {\n            \"type\": \"string\"\n        },\n        \"default\": {\n\n        },\n\n        \"definitions\": {\n          \"type\": \"object\",\n          \"additionalItems\": {\n            \"$ref\": \"#/definitions/JSDoc\"\n          }\n        },\n\n        \"type\":{\n      \"anyOf\":[\n        {\"$ref\": \"#/definitions/typename\"},\n        {\"type\": \"array\",\n        \"additionalItems\":{\n          \"$ref\": \"#/definitions/typename\"\n        }}\n      ]\n    },\n\n        \"allOf\":{\n          \"type\":\"array\",\n          \"items\":{\"$ref\":\"#/definitions/JSch\"}\n        },\n        \"anyOf\":{\n          \"type\":\"array\",\n          \"items\":{\"$ref\":\"#/definitions/JSch\"}\n        },\n        \"not\":{\n          \"type\":\"array\",\n          \"items\":{\"$ref\":\"#/definitions/JSch\"}\n        },\n        \"oneOf\":{\n          \"type\":\"array\",\n          \"items\":{\"$ref\":\"#/definitions/JSch\"}\n        },\n        \"enum\":{\n          \"type\":\"array\"\n        },\n\n        \"additionalProperties\": {\n          \"oneOf\": [\n            {\n              \"type\": \"boolean\"\n            },\n            {\n              \"$ref\": \"#/definitions/JSDoc\"\n            }\n          ]\n        },\n        \"minProperties\": {\n          \"type\": \"integer\"\n        },\n        \"maxProperties\": {\n          \"type\": \"integer\"\n        },\n        \"patternProperties\": {\n          \"type\": \"object\",\n          \"additionalProperties\":{\n            \"$ref\": \"#/definitions/JSDoc\"\n          }\n        },\n        \"properties\": {\n          \"type\": \"object\",\n          \"additionalProperties\":{\n            \"$ref\": \"#/definitions/JSDoc\"\n          }\n        },\n        \"required\": {\n          \"type\": \"array\",\n          \"items\": {\n            \"type\": \"string\"\n          }\n        },\n        \"dependencies\": {\n          \"$ref\": \"#/definitions/dep\"\n        },\n\n        \"items\":{\n          \"oneOf\":[\n            {\"$ref\":\"#/definitions/JSDoc\"},\n            {\n              \"type\":\"array\",\n              \"items\":{\n                \"$ref\":\"#/definitions/JSDoc\"\n              },\n              \"minItems\": 1\n            }\n          ]\n        },\n        \"additionalItems\":{\"anyOf\":[{\"type\":\"boolean\"}, {\"$ref\":\"#/definitions/schema\"}]},\n        \"minItems\":{\"type\":\"integer\"},\n        \"maxItems\":{\"type\":\"integer\"},\n        \"uniqueItems\":{\"type\":\"boolean\"},\n\n        \"minLength\":{\"type\":\"integer\"},\n        \"maxLength\":{\"type\":\"integer\"},\n        \"pattern\":{\"type\":\"string\"},\n        \"format\":{\"enum\":[\"date-time\",\"email\",\"hostname\",\"ipv4\",\"ipv6\",\"uri\"]},\n\n        \"multipleOf\": {\n          \"type\": \"number\"\n        },\n        \"minimum\": {\n          \"type\": \"number\"\n        },\n        \"maximum\": {\n          \"type\": \"number\"\n        },\n        \"exclusiveMinimum\": {\n          \"type\": \"boolean\"\n        },\n        \"exclusiveMaximum\": {\n          \"type\": \"boolean\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"typename\":{\n      \"enum\": [\"string\", \"integer\", \"number\", \"boolean\", \"null\", \"array\", \"object\"]\n    },\n    \"dep\":{\n      \"type\": \"object\",\n      \"additionalProperties\":{\n        \"anyOf\":[\n          {\"$ref\": \"#/definitions/JSDoc\"},\n          {\"$ref\": \"#/definitions/depArr\"}\n        ]\n      }\n    },\n    \"depArr\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"string\"\n      }\n    }\n  },\n  \"$ref\":\"#/definitions/JSDoc\"\n}}", 
            "title": "Meta - Schema"
        }, 
        {
            "location": "/spec/validator/", 
            "text": "Validator\n\n\nCheck yourself how the validation process works\n\n\nHere we provide the links to the validator our programming team developed as part of the JSON Schema project.\nThe validator is intended to follow the same guidelines defined in our formal specification.\n\n\n\n\nThe online version of the validator can be found \nhere\n. \n\n\nIf you want to fork the project or just check our code please visit us \nhere\n.\n\n\n\n\nThe validator was developed in Python 3.5 and has been stressed to several tests. If you want to check the tests please visit the following links:\n\n\n\n\nLink\n for the tests checking well-formedness.\n\n\nLink\n for the test suite.\n\n\nLink\n for the tests described in Foundation of JSON Schema.", 
            "title": "Check our Validator"
        }, 
        {
            "location": "/spec/validator/#validator", 
            "text": "Check yourself how the validation process works  Here we provide the links to the validator our programming team developed as part of the JSON Schema project.\nThe validator is intended to follow the same guidelines defined in our formal specification.   The online version of the validator can be found  here .   If you want to fork the project or just check our code please visit us  here .   The validator was developed in Python 3.5 and has been stressed to several tests. If you want to check the tests please visit the following links:   Link  for the tests checking well-formedness.  Link  for the test suite.  Link  for the tests described in Foundation of JSON Schema.", 
            "title": "Validator"
        }
    ]
}